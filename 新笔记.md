#### 基本 shell 命令

需要使用命令行，安装 git bash 即可。

##### ls 命令

查看当前目录下的所有内容

命令参数

- `-a` 查看当前目录下的所有内容包括隐藏文件

##### cd 命令

跳转目录
特殊的目录

- ~ 用户主目录，存储着很多默认配置

##### mkdir 命令

创建文件夹

##### touch 命令

创建文件，需要加后缀名

##### rm 命令

删除文件或文件夹

参数

- -r 删除文件夹
- -f 强制删除

##### pwd 命令

打印当前位置

##### cp 命令

复制或重命名
参数

- -r 可以复制文件夹

##### mv 命令

剪切

##### cat 命令

查看文件里面的内容

###### 安装注意

不需要选择安装目录，一直下一步，直到出现很多复选框其中有两个是 `git bash here` 和 `git gui here` 将后面的勾选掉(不勾选)，继续一直下一步即可。安装完毕之后在任意空白处点击鼠标右键就会出现 `git bash here` 命令。


#### git 的基本操作

#### 本地的项目已经做好了(做了一部分，项目刚开始)，向要传到 github 网站保存

##### 上传到网上非空仓库 (比如 [username].github.io)

- 先将网上的仓库下载到本地，需要使用命令 `git clone 仓库地址`
- 将想要托管的项目放到该仓库内，仓库内不必要的东西删除
- 将本地和网上关联起来(将自己本地的修改上传)
  - 将自己对仓库的所有修改添加到 github 远端记录,执行 `git add .`
  - 将记录好的修改做成版本，执行命令 `git commit -m'留言'`
    - 如果是第一次和 github 关联的话，会失败，然后会提示
      ```shell
        please tell me who you are ?
        让你依次分别执行以下命令
        git config --global user.name "yourname"
        git config --global user.email "youremail"
      ```
    - 告诉他之后再次执行 `git commit -m'留言'`
  - 将新的版本上传，执行命名 `git push`
    - 由于是第一次和网上关联，会失败提示
      ```
        让你执行
        git push -u origin master
        执行完毕之后就成功了
      ```
- 上传成功之后，想要修改的话，直接在本地仓库修改然后执行上传三部曲即可

##### 上传到网上空仓库 (我创建的 first_demo 空仓库)

- 网上传建一个项目同名(你的项目文件夹是什么名字，仓库名与之相同)空仓库(创建的时候不添加 reademe 文件)
- 在你的本地项目文件夹内打开命令行工具
- 将自己本地的项目初始化成 git 仓库，执行 `git init` 命令
- 执行 add 和 commit 命令(简写的需要自己补充)
- 去网上你的空仓库复制代码，第一个提示框的最后两行
  ```
    git remote add origin https://github.com/Sunny-zz/first_demo.git
    这行命令作用是给本地的仓库添加一个远端地址 名称叫 origin 地址是 后面的地址
    git push -u origin master
    将版本上传到已经添加的远端 origin
  ```
- 执行完毕之后上传成功，想要修改的话，直接在本地仓库修改然后执行上传三部曲即可

#### 使用 ssh-key 秘钥

将自己的电脑的当前系统和 github 关联。在上传或下载的时候使用 ssh 方式，省略输入用户民和密码。关联步骤如下

- 打开命令行工具 输入 `cd ~` 命令
- 执行 `ssh-keygen` 命令，生成电脑上的公钥和私钥，直接一直回车直到出现密码图即可。
- 找到生成的公钥和私钥，位置在 `~/.ssh/` 文件夹下，使用 cat 命令打印出公钥内容并复制 `cat .ssh/id_rsa.pub`
  - 如果生成的秘钥名称不是 id_rsa.pub 的话自己去找一下
  - 执行 `cd .ssh` 在执行 `ls -a` 查看自己的秘钥名称
  - 在使用 `cat 你的公钥` 去复制。
- 打开 github 网站，点击头像的下箭头选择 setting，找到 ssh key 新增一个即可。
- 验证 ssh 是否生效的话，需要重新从网上下载(选择 ssh 方式下载)仓库到本地，再次上传更新的时候就不需要输入用户名和密码了。

#### 多个人或者多台电脑对同一个仓库的同一个分支进行操作

- 同事 a 对 first_demo 仓库进行了修改，在 index.html 内添加了 一个轮播图，上传提交成功
- 同事 b 被要求添加一个 about 页面在项目内，做完之后上传执行 git 上传三部曲。执行 `git push` 失败提示远端存在本地不存在的版本，可以使用 `git pull` 命令。
- 执行 `git pull` 将远端的版本拉取到本地，但是本地已经存在了一个为提交的版本，

  当这两个版本不冲突的时候(不时同一个文件，或者同一个文件的不同位置)，

  - git 会自动合并两个版本，并弹出新的命令面板让你提交合并的版本留言，可以直接按住 shift 并按两下 z，退出留言面板。
  - 再次执行 git push，上传更新

  当这两个版本冲突的时候(修改的是同一个文件的同一个位置)

  - git 并不会自动合并，而是将冲突体现在当前的文件内，需要用户自己选择保留哪个更改，选择完毕之后，使用 git 上传三步提交。

#### github 的分支操作

一个仓库内可以有多个分支，默认只有一个分支 master ，通常称为主分支(用来放合并后的代码)。也可以创建无数个其他分支。一般工作流程是先在主分支将项目的主体框架搭建完毕，然后创建多个分支，每个分支代表不同的功能，不同的程序猿分别在不同分支内进行开发，开发完毕将代码合并到主分支。

- 创建一个仓库(breach_demo)带上 readMe ,然后克隆到本地，添加上公共的 css 和 js 然后上传。
- 创建新的分支 a 和 b，使用 `git branch a` 和 `git branch b` 命令。分支创建的时候里面的内容和主分支是一模一样的。
- 需要将创建好的分支上传到网上，可能直接使用 `git push` 就会成功,但是由于网上并没有新分支，所以需要使用 `git push --set-upstream origin yourbranch` 上传。
- 现在本地和网上同步(三个分支都同步了)，接下来就可以分开工作了。
- 分别切换到 a 分支和 b 分支，展开自己的工作，创建新的页面并上传。
- 主分支分别合并两个分支的内容，然后上传。需要使用 `git merge yourbranch` 命令合并分支。合并之后上传。

#### github 的特殊分支 gh-pages

拿我们创建好的 branch_demo 仓库来说，mater 分之内已经存放好了其他分支做好的项目(项目成品，包括 index...),github 仓库有一个特殊的分支叫 gh-pages ,该分支下的内容会被自动托管到 github 免费服务器(也就是说只要该分支下有 index.html 就可以直接使用网址访问)
只需要直接创建 gh-pages 分支，并上传到网上即可。

#### 仓库根目录下的 .gitignore 文件

gitignore 文件是一个隐藏文件，该文件的作用是当你将一些文件或文件夹的名称写在 .gitignore 内的话，该仓库执行上传操作的时候，会忽略 .gitignore 内添加的文件或文件夹

#### git 常用命令

- `git --version` 查看 git 版本号,有时候可以简写成 `-v`
- `git clone 仓库地址` 克隆仓库到本地
- `git add .` 将你的修改让远端记录 . 代表所有的修改 也可以换成文件名
- `git commit -m'留言'` 将记录好的修改做成版本,并提交版本留言
- `git push` 将做好的版本提交到远端
- `git init` 将本地项目变成仓库
- `git status` 查看当前仓库的状态
- `git log` 查看本地版本
- `git pull` 将远端的更新拉取到本地
- `git branch newBranch` 创建新分支
- `git branch` 查看分支
- `git checkout yourbranch` 切换分支
- `git merge yourbranch` 当前分支合并分支其他分支
- `git pull origin master` 拉取主分支上的更新
- `git checkout -b newbranch` 创建新的分支并切换过去

#### 注意

- 仓库不能嵌套仓库
- 版本回退

#### 类似 github 网站的其他工具

- 腾讯云开发者平台,是一个和 github 类似的网站，服务器是国内的操作起来很快。
- 码云 一般从 github 下载项目，可以通过 码云 下载

#### ECMAScript 6 es2015 新 js(ES6)

##### const 和 let

let const 和 var 的不同

- 不能重复声明
- 没有声明提升(先console,在赋值，var会显示undefined。但是let，const就错误提示)
- 存在块级作用域(作用域被定义在 {} 内) ??

const 是声明常量(不可修改的例如 π)的,常量的名称都是全大写的
let 声明的变量是可以被修改的

##### 变量的解构赋值

对象解构赋值

```js
const obj = {
  username: '貂蝉',
  userage: 18,
  level: 10,
}
const { username, userage: age } = obj
console.log(username, age)
```

数组的解构赋值

```js
const arr = [1, 2, 3, 4, 5]
const [a, b, c] = arr
console.log(a, b, c)
```

函数参数的解构赋值

```js
const obj = {
  username: '貂蝉',
  userage: 18,
  level: 10,
}
function showInfo({ username, level }) {
  // const { username, level } = obj
  console.log(`该英雄的名称是${username}`, `等级${level}`)
}
showInfo(obj)
```
忘记语法了！！
```js
const {value}=this
//const value=this.value
```

技巧: 实现变量调换

```js
let x = 1
let y = 2

[x, y] = [y, x]
```
const 的小应用
```js
const obj = {
  name: '吕布',
  age: 28,
}
obj.level = 15
//这样能加进去，因为const obj是地址，而改的是地址里面的东西，地址没变
```
```js
const obj = {
      name: '吕布',
      age: 28
    }
obj = {
      name: '吕布',
      age: 28,
      level=18
}
//这样就会报错，因为地址已经改了。
```
##### 字符串的扩展

模版字符串

```js
const username = 'lucy'
console.log(`my name is ${username}`)
```

新增的字符串方法
includes(), startsWith(), endsWith(), trimStart(),trimEnd(),padStart(),padEnd(),matchAll()

##### 函数的扩展

函数参数的默认值
普通方式参数非对象

```js
const fun = function (color = '黑色', bgColor = '红色') {
  console.log('颜色:::', color)
  console.log('背景色:::', bgColor)
}
fun('蓝色')
```

参数为对象

```js
const fun = function ({ color = '黑色', bgColor = '蓝色' }) {
  console.log('颜色:::', color)
  console.log('背景色:::', bgColor)
}
fun({ color: '粉色' })
// 不能什么都不传，最起码传递一个空对象
```

rest(剩余) 参数

```js
function add(...rest) {
  // console.log([...arguments])
  // ;[...arguments].forEach(function (ele) {
  //   console.log(ele)
  // })
  // 类数组 --->  数组
  console.log(rest)
  // rest 是数组
}
add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

箭头函数
写法

```js
// function add(num1, num2) {
//   return num1 + num2
// }
const add = (num1, num2) => num1 + num2
// 箭头函数定义只能变量式定义
// 箭头左边是 函数的参数部分 使用小括号包裹参数逗号拼接,当参数只有一个的时候可以省略小括号
// 箭头右边是 函数主体，使用花括号包裹，返回值设置依然使用 return。当函数不需要操作就设置返回值的话可以省略花括号和 return 直接写返回值即可
const res = add(10, 20)
console.log(res)
```

箭头函数和普通函数的区别

- 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
- 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

##### 数组的扩展

Array.from(): 将类数组转化为数组

```js
const fun1 = function () {
  console.log(arguments)
  console.log(Array.from(arguments))
}
fun1(1, 2, 3, 4, 5, 6)
const obj = {
  '0': 12312,
  '1': 98768,
  length: 2,
  // 随便
}
console.log(Array.from(obj))
```

数组新增方法 flat，flatMap

##### 扩展运算符

作用是对象的拷贝，还有类数组转化数组

- 对象展开
- 数组展开

```js
const obj = {
  name: '庄周',
  age: 18,
}
const obj1 = { ...obj }
obj1.hobby = '浪'
console.log(obj, obj1)

const arr = [1, 2, 3]
const arr1 = [...arr]
arr1.push(4)
console.log(arr, arr1)
```

##### 对象的扩展

对象的简洁表示法

```js
const username = '哈哈'
const userage = 20
const obj = {
  username,
  // 当对象的属性名和作为该属性的属性值的变量名相同时
  userage,
  // 函数可以省略 function，是普通函数
  say() {},
}
console.log(obj)
```

##### Symbol

第七种数据类型，生成独一无二的数据

##### set 数据结构

类似于数组，但是不能存重复的值

```js
const ary = new Set([1, 2, 131, 312, 1, 2, 131])
console.log(ary)
// 属性
// size
console.log(ary.size)
// 方法
// add() 向set数据内添加一个成员,返回数据本身
ary.add(1000)
console.log(ary)
// delete() 删除某个值，返回一个布尔值
//  has() 查看该值是否为Set的成员，返回一个布尔值
// clear() 清除所有成员
// 如何将 set 数据转化成数组
console.log([...ary])
```

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- Set.prototype.keys()：返回键名的遍历器
- Set.prototype.values()：返回键值的遍历器
- Set.prototype.entries()：返回键值对的遍历器
- Set.prototype.forEach()：使用回调函数遍历每个成员

还有一个额外的 WeakSet 数据结构,内部成员只能是对象类型

##### class 类

写法

```js
class Hero {
  // 类的花括号内默认一般只写方法，而且方法之间不需要逗号
  // constructor 是 class 自带函数，该函数被称作构造器和以前的构造函数类似
  // constructor 函数当 创建实例化类的时候自动触发
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  // 除了 constructor 函数之外定义的函数都相当于原来的 prototype 内的方法
  say = () => {
    console.log('我是王者荣耀的英雄' + this.name)
  }
}
const a = new Hero('牛', 20)
const b = new Hero('小乔', 18)
console.log(a)
console.log(b)
a.say()
```

继承

```js
class CarryHero extends Hero {
  constructor(name, age) {
    super(name, age)
    // super 调用了才真正实现了继承
  }
}
const c = new CarryHero('赵云', 19)
console.log(c)
```

#### node

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。
安装
直接百度 node 进入中文网直接下载安装包，直接进行安装不需要做任何的选择，一直下一步即可。
任意位置打开命令行工具，输入 `node -v` 和 `npm -v` 查看 node 和 npm 的版本号，如果有就安装好了,如果命令出错尝试重启电脑再次执行。

npm 是什么
安装好 node 之后 npm 就附带安装好了。他是 node package manager,node 包管理工具。

node 模块(后台，前端)

前端模块包括前端所有的 js 相关的包。

node 模块使用

- 新建文件夹，将该文件夹初始化为 node(npm) 的项目执行 `npm init -y`
- 新建 index.html 页面
- 安装 jquery 插件。执行 `npm install jquery`
- 安装完毕之后，项目内多了点东西
  - node_modules 文件夹，该文件夹是存储下载的包的地方
  - package-lock.json 文件，该文件是记录安装的包的详细信息的，不需要理会
- 在 html 中使用 jquery 可以按照之前的路径导入(不推荐)。但是现在是使用 npm 下载模块。可以使用 node 模块的方式导入安装好的包。 使用 `require(包名)`
- 但是当做模块导入之后浏览器报错。因为模块语法浏览器不支持需要编译。

npm 的使用
npm 就是下载 node 包的工具。
下载方式有三种

- `npm i 包名 --save`，这种方式一般下载的是项目的必须依赖,记录到 package.json 内的 dependencies 字段内。
  ```
    npm install jquery@2.3.4 --save
    npm i jquery -S
    npm i jquery
  ```
- `npm i 包名 包名 --save-dev`,这种方式安装的是项目的非必须依赖(工具类),记录到 package.json 内的 devDependencies 字段内
  ```
    npm install webpack --save-dev
    npm i webpack -D
  ```
- `npm i -g 包名`,这种方式是全局安装，当你想要在你的电脑上任何地方都使用包的时候进行全局安装。
  ```
    npm i -g server
  ```

卸载包使用 `npm uninstall 包`通过哪种方式安装的就怎样卸载。

npm 下载包的好处

- 可以使用模块导入
- 下载的包的信息全部记录在 package.json 内
- 同事之间相互传递项目的时候不需要传递 node_modules 文件夹。使用的时候只需要执行 `npm i` 命令会重新将所有的包下载一遍。

npm 的技巧，直接在任意位置的命令行执行即可

- 切换 npm 包的来源，默认的来源是外网服务器有点慢
  ```
    npm config set registry https://registry.npm.taobao.org
  ```
- 加上 http 显示配置，不让等待过程显得无聊。

  ```
    npm config set loglevel=http
  ```

提示：如果想在命令行里查看js浏览器中不支持的require，用 $ node 路径（$ node ./js/...），要想让浏览器认识，可以通过webpack编译
#### node 模块语法
- 前端模块分类 ：核心模块 第三方模块 自定义模块
- 模块导入： require('包名') 前两种模块直接写包名 自定义模块需要写路径
- 模块导出: module.exports={值}
(提示：没写{}默认导出第一个值，写了{}，那么两个都有或者 a:66)
#### 使用 webpack 打包编译我们的项目

你的 node 项目内使用 node 模块导入各种依赖，webpack 可以实现将模块的导入导出编译成浏览器认识的语法，也可以将所有的导入模块操作打包。
如何使用 [参考链接](https://www.webpackjs.com/guides/)

- 项目内安装 webpack
  ```
    npm install webpack webpack-cli  --save-dev
  ```
- 将 js 文件夹的名字改成 src，保证项目的根目录有 src ，并且 src 下存在 index.js，还有 index.js 是页面的主要用的 js
- 执行编译打包命令 `npx webpack`，会将 index.js 打包编译到项目下的 dist 文件夹下的 main.js
- 页面导入打包好的 js
- 上面是使用了 webpack 的默认配置进行的打包，可以在项目根目录下新建 `webpack.config.js` 文件，当作 webpack 编译的配置文件。参考网址 `https://www.webpackjs.com/guides/getting-started/#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6`,复制基础的配置到该文件内。
- 一直敲编译命令很繁琐，可以使用 package.json 中的 scripts 字段配置'快捷键'。使用 npm run 名 快捷执行。
  (提示：在package.json下的scripts里输入的 `"build": "npx webpack --config webpack.confi.js"`)

#### module

es6导入两种方式

- 默认导入
- 命名导入

导出两种种方式

- 默认导出
- 命名导出

#### es6 模块写法
// 模块路径 第三方和核心模块直接写包名

- 默认导入：`import x from "./index.js"`
- 默认导出: `export default a;`
- 默认导入和默认导出的名字可以不一样（x,a）,默认导出只能导一次，也只能导一个变量
```js
  //默认导入
  import x from "./index.js"
  import $ from "jquery"
  //默认导出a
  export default a
```
- 命名导入：`import xxx, { a as x, b } from "./about";`
            `import * as obj from "./about";`
- 命名导出：`export const a = 100;`
- 命名导入名字必须和导出一致，可以使用 as 换名
- 命名导出和默认导出可以同时存在,命名导出可以使用多次
- 全部导入不管是默认的还是命名的 obj 内存在所有的导出
- xxx 代表默认的，{}内代表命名的

#### ajax

Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）.
在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
现在已经进阶了，进阶成 Asynchronous JavaScript and JSON。

##### 原生 ajax

- 创建 xhr 对象
- 使用对象创建请求
- 使用 send 发出请求
- 使用 onreadystatechange 函数监听请求的过程，获取响应

```js
// get
const xhr = new XMLHttpRequest();
// 创建请求  open('请求的类型','地址','是否异步')
// 请求的类型 后台规定的
// GET  POST  PUT  PATCH DELETE ...
xhr.open("GET", "http://jsonplaceholder.typicode.com/posts", true);
xhr.send();
// 监听整个请求过程
// xhr.readyState 请求状态 0-4    4请求成功响应就绪
// xhr.status 请求状态码  200 ok
// xhr.responseText 返回的数据
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 可以获取后台数据
    console.log(JSON.parse(xhr.responseText));
    // 获取到的数据类似数组字符串   ---> json 串
    // 属性名和属性值必须使用双引号，数字和布尔值不需要，最后一项没有逗号
    // 使用 JSON.parse(json串) 转换
  }
};
// post 请求 类似登录
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://cnodejs.org/api/v1/accesstoken", true);
// 发送请求的时候需要传递给后台数据
// 但是原生 ajax 不能接收对象为参数，只能接收 json 串,而且得设置请求可以传递 json
// 需要使用 xhr.setRequestHeader() 设置请求头
// 添加 json 为可传递数据,使用 JSON.stringify 将对象转化为 json 串
xhr.setRequestHeader("Content-type", "application/json");
xhr.send(
  JSON.stringify({ accesstoken: "ecf878d1-6052-476a-8262-824760c7872b" })
);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  }
};
```

##### jquery ajax
- get 请求
- $.get(地址,参数,回调函数,返回内容的格式)
- 地址 后台接口地址
- 参数 请求的参数，不需要可省略
- 回调函数  成功之后的回调函数默认接收一个参数就是返回的结果
- 返回内容的格式  默认带 json 不需要设置
```js
$.get("http://jsonplaceholder.typicode.com/posts", function (res) {
  console.log(res)
  });
```
- post 请求
- $.post(地址,参数,回调函数,返回内容的格式)
- 参数的意思和 get 一致
```js
  $.post(
        "https://cnodejs.org/api/v1/accesstoken",
        { accesstoken: "ecf878d1-6052-476a-8262-824760c7872b" },
        function (res) {
          console.log(res);
        }
   );
```

常用方法 `$.ajax({配置对象})`

```js
// get（默认 type 是 get,不区分大小写）
$.ajax({
  type: "get",
  url:"http://jsonplaceholder.typicode.com/posts",
  success: function (res) {
    console.log(res);
  },
  // 请求失败的回调
  error: function (err) {
    console.log(err);
  },
})

//post
$.ajax({
  // 请求类型
  type: "POST",
  // 请求地址
  url: "https://cnodejs.org/api/v1/accesstoken",
  // 请求参数
  data: { accesstoken: "ecf878d1-6052-476a-8262-824760c7872" },
  // 请求成功的回调
  success: function (res) {
    console.log(res);
  },
  // 请求失败的回调
  error: function (err) {
    console.log(err);
  },
  // 请求结束的回调，无论是成功还是失败
  complete: function () {
    console.log("完事")
  },
  // 发给后台的内容类型 默认支持 对象类型
  // contentType: ""
  // 请求是否同域 false 代表同域请求  true 代表跨域请求
  // 一般来说后台独立解决了跨域请求的问题，不需要前端进行配置
  // 也有前后端一起解决跨域问题，后台需要前端做一些简单的配置
  // crossDomain: 布尔值
  // headers: 请求头的设置  可能需要配合后台做一些设置
});
```

请求的地址：`http://localhost:3008/posts?id=1`（自己建的）
```js
// 地址栏的问号部分就是查询部分
$.ajax({
  // url: "http://localhost:3008/posts?_limit=10&_page=1",
  //上面url和下面的两个是一样的，可以把？后面的查询部分写在data里
  url: "http://localhost:3008/posts",
  data: { _limit: 10, _page: 1 },
  success(res) {
    console.log(res);
    //结果拿到的是对象，后面加上.data就变成数组了
  }
});
```
      
##### axios ajax
axios 是专门的 ajax 请求插件，它里面的异步解决方案使用的是 promise。文档参考[网址](https://www.kancloud.cn/yunye/axios/234845)，axios的有点复杂的介绍[网址](https://www.kancloud.cn/yunye/axios/234845)
- 异步非阻塞
- 同步阻塞

```js
// get
axios
  .get("http://localhost:3008/users", {
    params: {
      _limit: 20, _page: 2
    },
  })
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.log(error);
  });
// axios 就是使用 promise 封装了异步操作
// axios.get('地址').then(res=>{}).catch(err=>{})
// then 是成功函数  res 是成功的返回值  axios 会将后台的数据存储到一个对象的data属性内


// post
axios
  .post("https://cnodejs.org/api/v1/accesstoken", {
    accesstoken: "ecf878d1-6052-476a-8262-824760c7872b",
  })
  .then(res => {
    console.log(res.data);
  });
```
异步同步的小例子
```js
setTimeout(() => {
    // 异步完毕之后执行的事
    console.log("异步完毕");
  }, 1000);
  console.log(1);
  // 嵌套很多的回调，一旦某一环节需要做额外的判断处理
  // 回调地狱
  $(".box").slideDown(1000, function () {
      $('.bxo')
  });
```
promise（把异步操作放在promise里的小例子）
```js
//第一种简单的小例子
let num = 10;
console.log("正在干活计数");
const promise = new Promise(function (resolve, reject) {
  // resolve 函数的意思就是成功的回调函数
  // reject 函数的意思就是失败的回调函数
  setTimeout(() => {
    num = 100;
    if (num === 100) {
      console.log("活干完了");
      resolve();
    } else {
      console.log("有点问题没做完");
      reject();
    }
  }, 1000);
});
// .then 就是传递 resolve 函数
// .catch 就是传递 reject 函数
// 避免了回调嵌套
promise.then(function () {
  console.log("计数完成了，进行下一步操作");
});
promise.catch(function () {
  console.log("没干完，得继续干");
});

//第二种一般这样使用的小例子
function timeout(ms) {
  return new Promise((resolve, reject) => {
    console.log("异步操作正在执行");
    setTimeout(resolve, ms, "done");
  });
}

timeout(1000).then(value => {
  console.log("执行完毕之后做的事");
  console.log(value);
  //value的值是done，详解如下一个js
});
```
```js
setTimeout(
  (value, value1) => {
    console.log(value, value1);
  },
  1000,
  1,
  2
);
// 输出1 2，具体为什么自己想,hahaha 
```
##### 使用 json-server 模拟后台数据库

- 全局安装 json-server `npm i -g json-server` 可能有点慢,安装一次就够了
- 在需要的地方新建 xxx.json 文件,还文件内写法如下
  ```json
  {
    "users": [
      {
        "id": 121,
        "username": "小王"
      },
      {
        "id": 21,
        "username": "小二"
      }
    ]
  }
  ```
- 这样的 json 文件生成的数据代表 users 列表数据
- 数据列表中最后不能加逗号，可以写多个列表数据（接口）
- 接口文档的值必须是对象或数组（users是一个接口，可以有多个接口）
- 在该 json 文件所在的地方打开命令行工具，启动数据库服务。`json-server --watch xxx.json -p 3000`，命令执行完毕之后，数据库就启动了，不要关闭该服务。安装上述 json 文件，启动的服务可以使用 'http://localhost:3008/users' 接口就能访问用户列表了。
- 更详细的接口文档说明参考[json-server](https://github.com/typicode/json-server)(就是去掉接口名)

##### 将自己的项目跑在本地服务器上

- 全局安装 serve `npm i -g serve`,安装一次就够了
- 在你的项目内打开命令行工具执行 `serve .`
- 执行完毕之后你的当前项目内的所有文件已经被跑在了 `http://localhost:5000` 服务器上，默认打开 index.html

##### 项目服务器

项目的开发阶段，前端页面跑在本地(局域网)服务器上，后台数据库服务器只能公司内部访问。

# vue 框架
## vue安装

想要使用 vue 开发项目，需要安装 vue 的开发环境。官方网站提供了安装环境的脚手架工具 vue-cli。使用命令 `npm install -g @vue/cli` 全局安装脚手架工具。工具安装好之后就可以搭建 vue 的开发环境了。有两种方式搭建

- vue create 命令，在想要创建项目的文件夹下执行 `vue create 项目名`。
- 图形化界面工具。任意位置执行 `vue ui` 在浏览器中调出图形化界面，创建 vue 项目。
  - 选择上方的创建按钮
  - 选好项目所要创建的位置
  - 选择默认的预设模版
  - 创建
  - 创建完成之后，选择 任务-->serve-->运行-->启动 app
  - 运行还可以使用命令：npm run serve
  - 此时 vue 的基础项目已经搭建完毕。

## vue 初始项目结构

- node_modules 该项目依赖包的存放位置
- .gitignore 作为 github 仓库忽略上传的记录
- package.json 记录了 node 项目的基础配置，和一些 vue 项目的配置
- package-lock.json 详细记录项目所用到的包
- README.md 项目介绍文件
- public 该文件下存在的是项目的 html 模版,意思就是你写的所有的 vue 代码其实都是以该模版为基础的，一般不需要修改，偶尔可能会引入一些文件(css js 等工具类的)
- babel.config.js babel 的配置文件，babel 是一个 js 编译工具，作用是编译新版本的 js 语法。
- src 文件夹是 vue 项目的源代码
  - assets 存储静态文件的文件夹，一般存放一些 公共的 css 图片等
  - components 存放 vue 组件的，文件夹名称可以修改
  - app.vue 该文件就是 vue 的最外层组件
  - main.js 该项目的入口文件，意思是 webpack 会将该文件打包编译。该文件内写的是 vue 一些全局设置。

## spa 单页面应用

vue 项目创建的就是单页面应用。整个项目就在一个页面内。参考文档[单页面](https://www.jianshu.com/p/0c32c85c668b)


## vue 组件

整个 vue 项目就是由各种各样的组件组合而成的。组件可以理解成我们原来排版的某一个结构部分。app.vue 组件是项目的最外层结构。在 vue 项目中，最简单的组件写法就是以 vue 为后缀名的文件，组件名称一般首字母大写，多个字母使用大驼峰方式命名。
如何划分组件，其实就是和之前画盒子一样。
vue 后缀的组件构成

- html 部分，使用 template 标签表示，里面写 html 即可，也可以嵌入其他的组件，需要注意的就是该 template 标签只能有一个子级
- script 组件的 js 部分。自己页面的逻辑处理，其他组件的注册。
- style 组件的 css 部分，默认的样式是全局的。

## components 的作用

## main.js 的作用
```js
import Vue from "vue";
// 导入 Vue
import App from "./App.vue";
// 导入 最大组件 app
import "./assets/style.css";
// 导入全局的 css
Vue.config.productionTip = false;
// Vue 项目的配置去掉生产版本提示
// 现在是开发阶段，看不到打包之后的代码，打包之后的代码被托管到服务器上，所以我们可以通过访问服务器地址访问我们的项目
new Vue({
  render: h => h(App)
}).$mount("#app");
// 创建 vue 实例 添加render配置，作用是需要渲染的组件
// 实例创建好之后使用实例的 $mount 方法将实例挂载到页面的 #app 结构内
```
## 整理初始项目(删除一些内容)

App.vue 只剩下

```js (vue)
  <template>
    <div id="app">hello world</div>
  </template>

  <script>
    export default {
    name: "App"
  };
  </script>

  <style></style>
```

删除 HelloWorld 组件

## 组件样式

组件的样式基本上都是全局的，因为只有一个页面，所有的组件都会渲染到同一个页面。

- 在 style 标签上加上 scoped 属性，使组件样式私有化
- 在 style 标签上加上 lang 属性，可以设置使用高级 css 扩展语法(less sass)

## 组件的嵌套

1. 先在父组件内导入子组件
2. 在父组件内的导出对象内使用 components 属性先注册子组件。

  ```js （app.vue）
  <script>
   // 第一步，先在父组件内导入子组件
    import Header from "./components/Header";

    // 在组件内js部分必须默认导出一个对象，而且该对象下一般必须设置一个属性 name 属性值可以和组件名一致，不能和 html 标签命名冲突
    export default {
      name: "App",
      // 第二步 组件注册
      components: {
        // Header: Header,
        // 对应的是在wrap里引用的那个：上面导入的变量
        Header,
      },
    };
  </script>

  <style scoped>
  // scoped 的作用就是给该组件的所有标签加上一个随机属性(和所有组件都不同)，所有选择器都添加上了该属性的属性选择器
  // 那么加了 scoped 属性的样式就变成了私有样式了 
  </style>

  ```

3. 在父组件的 template 内直接使用组件名称的标签即可
  ```html
  <div class="wrap">
    <header />
    <!-- header 名字任意起的 -->
  </div>
  ```

## 组件的复用技巧 props

当一个组件需要在很多个组件内使用，而且多多少少显示的内容不一样，其实是需要根据组件所在位置进行轻微的修改。此时就可以借助 vue 内的 props 知识点处理。
父组件嵌套子组件的时候希望子组件要根据我的想法修改一些内容。
props 的使用
1. 在父组件内，直接当做自定义属性传递即可

```html
<Button value='warning' text="Download Now" color="#00f" :isActive="true" />
```

2. 在子组件内，需要使用导出对象下的 props 属性接收
方式一数组

```js
export default {
  name: "Button",
  // 接收的时候使用字符串  数组方式
  props: ["text", "color"]
};
```

方式二对象

```js
export default {
  name: "Button",
  // 对象方式 高级可以做简单的校验
  props: {
    text: {
      //  可以设置属性的类型和默认值
      type: String,
      default: "default button"
      // required: true,
      //必填的字符串，和default冲突,两个一起写default生效，但还是会提示红色错误
    },
    isActive: {
      type: Boolean,
      default: false
    },
    value: {
      type: String,
      default: "success",
      // 可以自定制匹配校验
      validator: function (value) {
        // value 代表的就是父组件传递的值
        // 这个值必须匹配下列字符串中的一个,能执行，但也出现红色错误
        return ["success", "warning", "danger"].indexOf(value) !== -1;
      },
    },
  }
};
```

3. 接收完毕之后需要在 template 中使用，使用方式分为**两大类**

- 在标签的尖括号之间使用，直接用双花括号嵌套 props 名称即可

  ```html
  <button class="btn">{{text}}</button>
  ```

- 在标签的属性内使用,需要使用 vue 指令 `v-bind:` 也可以直接省略使用 `:`

  ```html
  <!--  语法就是 v-bind:属性名='这里面直接写js即可'  v-bind: 可以简写成 : -->
  <!-- <button :style="'background-color:'+bgColor " class="btn"></button> -->
  <button :style="`background-color: ${color}`" class="btn">按钮</button>
  ```

## vue 的模板语法

我们在介绍 prop 的时候就已经使用了 vue 的模板语法。在 template 中嵌入 js。
分为两大类

- 在标签的尖括号之间使用，直接用双花括号嵌套 props 名称即可
- 在标签的属性内使用,需要使用 vue 指令 `v-bind` 也可以直接省略使用 `:`

## 复用技巧的小整理：

1. 只要是在 template 想要使用 js 的话都遵循两个语法，也就是以上**两大类**
2. v-bind:属性名='这里面直接写js(只能是值或者运算不能是语句)即可
3. `<button :class="`btn ${isActive ? 'color' : ''}`"></button>`

## vue 组件的 data

- 只要是组件的 html 内容(结构，样式...)发生改变的话，那么这个改变必须由 data 内的某个 数据 控制。
- 之前想要点击按钮修改颜色，必须获取真实的 box 的 dom 节点，然后修改
- 其实上述方案可能会导致浏览的重排和重绘
- vue 为了解决上述问题使用的 虚拟 dom 的概念
- 页面的所有的变化必须由组件的 data 的改变而变化

使用方法

1. 需要将变化对应的内容设置成 data
  ```js
  export default {
    name: 'App',
    data: function () {
      return {
        bgColor: 'red',
      }
    },
    ...
  ```
2. 将 data 应用到页面中，使用的时候就相当于一个变量
```js
div v-bind:style="`background-color:${bgColor}`" class="box">
  <button>单机变蓝</button>
</div>
```
3. 使用 js 逻辑修改对应的 data 页面自然就会跟着变化了

- data 的使用
  - 在 template 中使用直接当成变量，使用模板语法写到标签内即可
  - 在 script 内使用的时候要用 `this.名` 访问
- data 的修改
  - 在 template 中的函数内直接对 data 赋值即可
  - 在 script 函数内使用 `this.名` 重新赋值,这种表较常用

## vue 组件内的事件绑定

直接使用 v-on 指令绑定事件，也可以简写成 @ ,vue里没有hover事件，可以写成mouseenter事件

```html
<button v-on:click="change()">单机变蓝</button>
<button @click="change()">单机变蓝</button> 
 <!-- @事件类型='事件函数(可以使 methods 内设置的，也可以是直接写的)' -->
<!-- 所有vue指令的值的引号内都可以直接写 js 语法 ，@click就算是一种指令，后面的值里可以用js -->
<!-- 以上需要写methods对象，以下不需要写methods对象  -->
<button @click="function(){bgColor='blue'}">单机变蓝</button> 
<button v-on:click="()=>{bgColor='blue'}">单机变蓝</button>
 <!-- 事件函数内只要有修改 data 的操作，那么上述写法可以直接简化成： -->
<button v-on:click="bgColor='blue'">单机变蓝</button>

```

```js
<span>成绩：{{grade}}</span>
<br />
// 由于函数没有返回值所以update(190)的返回值是undefined，而vue指令的功能可以这样写，还可以写成： -->
// <button v-on:click="function(){update(200)}">修改成绩</button> -->
// 以上 function是事件函数，update是普通函数 -->
// 没有function函数，update无论有参没参都是事件函数 -->
// 只要是事件函数就有event参数，可以直接用 -->
<button v-on:click="update(190)">修改成绩</button>
```

change 是一个函数名，该函数必须声明在，组件导出的对象下的 methods 属性内，注意的是 这里面的函数在 template 内使用的时候直接使用方法名，而在 script 中使用的时候需要使用 `this.方法名`

```js
  methods: {
    // 该对象下的属性需要写成函数，这个函数可以直接当作事件函数，也可以当作普通函数
    change() {
      this.bgColor = 'blue'
    },
    update: function (value) {
      // update: () => {
      // console.log(this.grade)
      // 箭头函数：Cannot set property 'grade' of undefined"
      //箭头函数和普通函数的this指向不一样，所以箭头函数出错
      this.grade = value;
      console.log(this)
      // 普通函数的 this 指的是组件实例，指的就是这个组件本身
      // 我们可以直接通过 this 能访问到  组件的 data methods  props ...
      console.log(event);
      // 这个事件函数不用传参，直接能用,event显示一个mouseEvent的对象，这个event是从事件函数那来的
    },
  },
```

## 组件间的通信

爷孙组件

- 把del方法使孙子用，爷组件用:delete="del"，儿子接收@delete='delete'，孙子直接用 @click="delete"
- 需要注意，不能用delete关键字，以上我懒的改了！

父子组件

- 使用 props，props 一般用来传递值,也可以传递函数(一般不使用)
```html
<Span :slide1="slide" text="asdsdfsf" />
```
- 自定义事件， 向子组件传递函数，一般是当父组件的 data 想要让子组件修改时使用
- 给子组件设置 ref
    
    父组件中
    ```html
    <!-- content是组件名 -->
    <Content ref="ceShi" />
    <button @click="handle">测试ref</button>
    ```
    ```js
    handle() {
      this.$refs.ceShi.xxx();
    },
    ```
    子组件中
    ```js
    xxx() {
      console.log(111);
    },
    ```
- 子组件也可以传递给父组件函数让父组件使用

  子组件内
  ```html
  <button @click="$emit('add',clearInput)">按钮</button>
  ```
  ```js
  methods: {
    clearInput() {
      console.log(111)
    },
  },
  ```
  父组件内：
  ```js
  methods: {
    add(callBack) {
      //在add里用的时候当作函数调用
      callBack()
    },
  }
  ```

- 父组件内使用 \$children 可以获取所有子组件的实例组成的数组
  ```js
  //只能在mounted里log，因为mounted渲染完毕了。
  mounted() {
    console.log(this.$children[0]);
  },
  ```
- 子组件内使用 \$parent 获取父组件实例
  ```html
  <!-- 也可以不传props直接使用，但是推荐用props。 -->
  v-for="item in $parent.shuJi"

  <!-- 直接使用爷爷的事件： -->
  <button @click="$parent.$parent.del(shuJi.id)" 
  ```
  ```js
  mounted() {
    console.log(this.$parent);
  },
  ```
  
兄弟组件

- 将兄弟间需要相互使用的 data 共享到父组件内，那么兄弟之间的交互就变成了父子之前的交互了

## 自定义事件
- 父组件向子组件传递函数需要使用自定义事件，其实也可以直接使用 props,自定义事件名称推荐使用ebab-case 命名，不使用 camelCase 方式（驼峰）
父组件内
语法： @自定义事件名称="父组件内的函数名称"

```html
<!-- 第一种方式时直接将函数传递过去 -->
<Button @change1="change"></Button>
<!-- 第二种方式是将带参数的函数传递过去 -->
<Button @change1="change(index)"></Button>
```

子组件内
js 内

```js
  methods: {
    handleClick() {
      // 接收父组件传递过来的函数并调用
      this.$emit("change1");
      // 这是传参调用
      // this.$emit("change1",4);
    }
  }
```

tenplate 内

```html
<button @click="handleSlide">
  {{ text }}
</button>
```
```html
<button @click="$emit('changeSearchValue',1)" />
```

自定义事件还有一个修饰符 .native ,该修饰符的作用就是将自定义事件直接绑定在子组件的根元素标签上，但是这类自定义事件名称必须和原生事件名称相同。

```html
<!-- 直接给子组件 Button 的根元素绑定了 click 事件 -->
<Button @click.native="change"></Button>
```
## 小提示
1. 子组件想要修改父组件的 data ？
    - data 只能在自己的组件内使用 this.dataName 修改，想要让其他人修改自己组件的 data ，那么需要先在自己组件内定义好修改的方法，然后将该方法传递给其他组件去执行
2. 为什么选择一个 data 不设置两个？
    - 因为只要定义了一个 data 那么 vue 就有针对这个 data 做一套虚拟 dom 流程
3. 如果图片的 src 地址写成了 js 相关的值，那么图片不会解析在浏览器上，解决方案：
    - 换成网络地址 推荐
    - 将 js 生成的图片地址使用 require(js地址) ,只能在 script 标签中使用
    ```html
    html
    <!-- 用变量的话这样用 -->
    <li :locate="require('../'+item.locate+'.jpg')"></li>
    
    js
    liArr:[{locate:"assets/p1"}]
    ```
4. 以后我们自己做项目的话可能会用到一些图片，这些图片写成本地的话不太好，将我们的图片上传到 github  或者 腾讯云 或者其他的免费网站
5. 报错 Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. 意思是：请避免直接修改 prop ，在父组件重新渲染的时候该属性会被重写（避免在子组件内修改父组件传过来的data）
6. 在 template 中当事件函数内想要使用事件对象请使用 $event
  ```html  
  <input type="text" @input="$emit('change-searchvalue',$event.target.value)" /> 
   <!-- 传的参数是dom节点的值 -->
  ```
7. 三目运算符的优先级低于 &&
8. if语句的简写方式，条件成立时，执行后面的语句，后面的语句必须和if在同一行
```js
if(value) console.log(111),(console.log(222))
else console.log(333)
```
9. 想按回车就添加，就v-on:keyup 或者可以keydown都可以，回车的编码是13，把enter 换成13也对
    ```html
    <input
    type="text"
    v-model.trim="value"
    @keyup.enter="handleClick"
    />
    ```
10. gitbash 不可用，使用 powershell 运行 vue ui 提示

  ```
  无法加载文件 C:\Users\sunnyzz\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https
  :/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
  ```

  以管理员身份打开命令行输入 `Set-ExecutionPolicy RemoteSigned` 然后输入 Y 。再次运行 vue ui 即可

11. 字体图标和自动生成代码（自定义代码片段）的视频是2020.8.31
12. 生命周期是同步的，发送请求是异步的
13. form 里的button 默认就是submit,想要需要写成如下：
  ```html
  <!-- event.preventDefault  阻止默认行为  a的超链接 表单的默认提交和重置  -->
  <button @click.prevent">确定</button>
  ```
14. 想要使用axios插件，需要在依赖下安装，在代码中引入
  ```js
  import axios from 'axios'
  ```
15. computed 该计算属性是在页面初始的时候就执行，所以在父组件的 computed 内无法获取子组件实例，也就是不可以使用 $refs 和 $children（因为子组件的created还渲染完，涉及到生命周期问题）

16. 事件修饰符 stop 阻止事件向上触发（在父级中写的click事件，在子级中也会触发，想要阻止就用stop）
  ```html
  <div @click.stop class="dialog">
  ```
17. get是请求(res是整个数组)，delete是删除(什么也不返回res是空的)，patch是修改(res返回修改之后的那条对象，而不是整个对象)，post是添加(res返回要新加的那一项),还有一个put（put和post都是修改，区别是put是更新，也就是更新所有项，而post是修改，可以只修改需要的某项）
  ```js
  axios.get("http://localhost:3000/books").then((res) => {
    console.log(res.data)
  // 整个数组
  });

  axios.delete("http://localhost:3000/books/" + id).then((res) => {
    console.log(res.data)
  // {} ， 输出空的。删除这条id和对象
  });

  axios.patch("http://localhost:3000/books/" + id, newBook).then((res) => {
    console.log(res.data)
    // 返回修改之后的那条对象也就是newBook，而不是整个对象
  });

  axios.post("http://localhost:3000/books", newBook).then((res) => {
    console.log(res.data)
    // 返回要新加的那一项，也就是newBook
    this.shuJi.push(res.data);
    // 想要显示在页面上，还需要添加上这一条对象，要不然是后台更新了，前端还没更新，不过一刷新就又有了
  });
  ```
18. 代码片段：按Fn+F1，输入snippets，选择首选项代码片段那个，然后选择vue.json, 默认有个log,的代码片段。地址[https://blog.csdn.net/maokelong95/article/details/54379046]
  ```js
    "Print to console": {
      "prefix": "log",
      "body": [
        // $1代表的是光标，${TM_FILENAME_BASE代表组件名
        "console.log('$1');",
        "$2"
      ],
      "description": "Log output to console"
    }
  ```
19. 当每个按钮对应每个点击事件时，没有必要写三个事件，可以写成一个 xx(属性名，属性值){this[名]=值}
  ```html
  <button @click="x(one,'one1')">按钮</button>
  <button @click="x(two,'two1')">按钮</button>
  ```
  ```js
  methods: {
    x(name, zhi) {
      this[name] = zhi;
    },
  },
  ```
## 列表渲染

将一组数据循环渲染到页面上，需要使用指令 `v-for`
循环渲染两种情况

- 带数据的(有 data)
  <!-- item in arrList 就相当于遍历数组 arrList, item 代表每一项, -->
  ```html
  <!-- 想要使用下标的话  (item,index) in arrList -->
  <li v-for="(item,index) in arrList" :key="index">{{item}}</li>>
  ```
  ```html
   <!-- key 属性是必须的 而且该循环下唯一 -->
  <li v-for="item in arrList" :key="唯一值">{{item}}</li>
  ```
- 就是循环很多次，不需要 data。这种很少见
  <!-- 循环10次 -->
  ```html
  <li v-for="item in 10" :key="唯一值">{{item}}</li>
  ```
  
## 条件渲染

使用两个指令

- `v-show` 样式的消失和出现
  ```html
  <div v-show="listArr.length">
  <!-- 数组有值的情况下显示 -->
  ```
- `v-if` 可能搭配 `v-else` `v-else-if` 结构真正消失,需要注意 if else  elseif 使用的时候必须紧跟着中间不允许出现其他的元素，而且该指令对应的元素都是兄弟元素 
  ```html
  <span v-if="ind==0">1</span>
  <span v-else-if="ind==2">2</span>
  <span v-else-if="ind==3">3</span>
  <span v-else>4</span>
  ```
- 消失出现次数比较频繁使用 show, 消失出现次数比较少使用 if（show 只是显示隐藏，if就是有或没有，老师推荐使用v-show）

## style 和 class 绑定

style 行内样式 和 class 名在 vue 组件内的多种写法，其实就是为了更简单的去实现样式的修改。
style 绑定

- 默认的字符串方式
- 对象表示法
  ```html
  <!-- 古老的修改style的方法，因为fontSize中间有-，所以要加引号 -->
  <!-- <div class="box" :style="{'font-size': '50px'}">style</div> -->
  <div class="box" :style="styleObj">style</div>
  ```
  ```js
  data: function () {
    return {
      isHas: true,
      styleObj: {
        color: "red",
        fontSize: "50px",
      },
    };
  },
  ```
- 数组表示法((较麻烦不好用，老师没讲))

class 绑定

- 默认的字符串方式
  ```html
  <div class="box"></div>
  ```
- 对象表示法
  ```html
  <div :class="{box:true,active:true}">style</div>
  ```
- 数组表示法
  ```html
  <div :class="['box',isHas?'active':'']"></div>
  <div :class="['box','active']"></div>
  ```
- 数组内嵌套对象表示法
  ```html
  <div :class="['box',{active:true}]"></div>
  ```
  ## vue 的表单

vue 将表单的输入(文本)绑定成组件的 data ，用组件的 data 去控制。vue 提倡使用 v-model 指令去实现表单的绑定。我们也可以使用 value 配合 input 或者 change 事件替代 v-model 指令。

老方案：
```html
<input type="text" @input="handleChange" :value="username" /> 
```
```js
// data里，
username:"名字"
// 事件里，
handleChange(){
  // 先获取真实 dom 节点  event.target
  this.username = event.target.value;
}
```
新方案：
```html
<!-- change 对于 input：text | password 是属于失去焦点事件 -->
<!-- input 对于 input：text | password 是域的内容发生改变就会触发  -->
<!-- 使用 v-module 简化表单的双向绑定 -->
<input type="text" v-model="username" />
```
```js
data:function(){
  username:'名字'
  //此时username随便内容变化而变化，不用写事件
}
```
v-model 指令的修饰符

- .lazy 实现懒加载将 v-model 的默认事件从 input 改成 change
- .number 自动将输入的值使用 parseFloat() 转化成数字类型
- .trim 自动将输入的值的左右空白去掉
  ```html
  <input type="text" v-model.trim="password" />
  ```

## vue 组件的计算属性

你想对一个 data 进行复杂的逻辑操作后在放到页面上展示，此时我们可以直接将复杂的操作写在模版语法内，或者使用函数操作之后返回想要的值。但是 vue 组件提供了更好的方法 就是组件的计算属性(computed)，用法和 data 一致

```js
// 计算属性就是一个函数，该函数必须返回一个值，这个值就是计算属性，计算属性函数不可以传递参数
computed: {
    typeList() {
      return this.arr.reduce((res, item) => {
        if (!res.includes(item.category)) {
          res.push(item.category);
        }
        return res;
      }, []);
    }
  },
```
reduce是数组的遍历，箭头函数可以不写return，而对于返回对象来说的说，可以去掉return，把{}换成(),res是最终的结果，item是遍历的每一项， { totalPrice: 0, totalNum: 0 }是res的初始值，函数里要返回新的结果来继续遍历，遍历之后res为最终的结果。
```js
computed: {
  total() {
    return this.products.reduce(
      (res, item) => {
        return {
          totalPrice: res.totalPrice + item.price * item.quantity,
          totalNum: res.totalNum + item.quantity,
        };
      },
      { totalPrice: 0, totalNum: 0 }
    );
  },
  // total() {
  //   return this.products.reduce(
  //     (res, item) => ({
  //         totalPrice: res.totalPrice + item.price * item.quantity,
  //         totalNum: res.totalNum + item.quantity,
  //     }),
  //     { totalPrice: 0, totalNum: 0 }
  //   );
  // },
},
```

```js
// 一会研究一下！
const newArr = new Set(arr.map(item => item.category));
```

## vue 组件的 ref

当你想在 vue 组件内获取一个元素的真实 dom 结构的时候，可以使用原生方案 document 一套，也可以借助插件(没讲)。但是呢，vue 其实提供了一个方案，就是组件的 ref。一般获取真实 dom 节点用于获取某个值，并不是用于修改。

```html
<button ref="btnDom"></button>
```

```js
this.$refs.btnDom;
// 就是获取了 button 的原生 dom
```

其实 ref 也可以直接写在组件上,那么获取的就是该组件实例，也就是说可以获取组件内的所有内容。进而也就可以实现父子组件之间的交互。
```html
<li ref="ceShi"/>
<!-- li是组件 -->
```
```js
console.log(this.$refs.ceShi.arr)
//this.$refs.ceShi 相当于该组件里面的this.arr
// 也可以调用子组件的方法
this.$refs.ceShi.方法名()
```

## 组件内的 this

组件内使用 this 其实就是想要使用该组件下的 data props methods computed 自定义事件 ref ... ,那么组件内我们通常使用的 this 就指的是该组件的实例(VueComponent)。
如何获取组件实例

- methods 将函数设置成普通函数，该函数的根作用域下的 this 就是组件实例.如果根作用域内的其他子作用域想要直接访问 this 那么请设置成箭头函数（箭头函数下的this 就是vue组件，而普通函数下的this就是调用的window，比如，settimeout）
- computed 跟上面 methods 一样
- 生命周期函数跟上面一样

## 组件的生命周期

组件从出现到渲染页面或者再页面中销毁，各个阶段 vue 都提供了对应的函数，供开发者使用。这些函数被称作生命周期钩子。生命周期钩子是同步函数。

初始渲染阶段

- beforeCreate
- created: data 等其他组件的数据处理完毕,可以在页面初始的时候发送请求更新数据。发送请求使用的是 axios 插件。
- beforeMount
- mounted: 组件在页面渲染完毕，可以获取组件内的真实 dom 节点。

数据更新阶段

- beforeUpdate 数据更新时调用，发生虚拟 dom 打补丁之前
- updated 数据更新完毕，dom 渲染完毕

组件的销毁阶段

- beforeDestory 组件即将被销毁，并不是组件的内容在页面上消失
- destoryed 组件销毁完毕，v-if属于销毁，v-show不属于，需要写在组件内，销毁的是组件。 我们在这个生命周期内，可以手动解除一些跟该组件的无关的一些操作(setInterval 跟浏览系相关的一些事情，setInterval属于浏览器，所以即便组件销毁了，setInterval也不会停止)

```js
// 生命周期
// 阶段 一
// 初始渲染阶段 (其实就是页面刚进入的时候或者刷新的时候)
// 该阶段需要实现的大概有 获取页面初始数据(进入页面就向后台获取数据然后更新页面，或者其他的一些进入页面就需要做的事)
beforeCreate() {
  console.log("组件刚被创建，在初始化data之前");
},
created() {
  console.log(
    "组件的数据观测 (data observer)，property 和方法的运算，watch/event 事件回调,配置完毕"
  );
  // 此阶段最适合进入页面就修改 data ，发送请求获取后台数据，修改 data
  axios.get("http://localhost:3000/articles").then(res => {
    // console.log(res.data);
    setTimeout(() => {
      this.articles = res.data;
    }, 1000);
  });
},
beforeMount() {
  console.log("组件即将要渲染，挂载之前");
},
mounted() {
  console.log("渲染执行完毕");
  // console.log(document.querySelector(".title"));
  // 刚进入页面想要获取真实的 dom 节点做一些功能，在此阶段可以实现
  // 比如说 swiper 插件  使用的时候  new Swiper('.container')  需要获取真实 dom 节点 container
}
```

## axios 封闭
```js
app.vue
// 其中地址可以写成空，因为可以设置默认地址，有时也可以删除，切记一一对应
$http("delete", id) //id对面自动连接上
$http("post", "http://localhost:3000/books", newBook
$http("get", "http://localhost:3000/books")
$http("patch", newBook.id, newBook)
//可以传过去对象，对面接收语法是config，
$http({ method: "delete", url: id });
$http({ method: "post", data: newBook })
$http({ method: "get" })
$http({ method: "patch", url: newBook.id, data: newBook })

//可以传三个参数过去

```

```js
axios.js
// 先是导入js，两种方式
import $http from "./axios"; // 默认导入
import { $http } from "./axios"; // 命名导入

// 封装 axios 请求
// 将请求整合到一处便于管理
// 默认导出
import axios from "axios"
// axios 请求就会返回一个 promise
// 当你的请求都是基于一个服务器下的时候，可以给请求设置基地址
// 配置 axios 请求的默认基地址
axios.defaults.baseURL = "http://localhost:3000/books"
// export default (type, url, params) => {
//     return axios[type](url, params)
// }
export default config => {
    return axios(config)
}
// 将函数的参数设置成对象的话比较好
// 因为将对象拆分成三个参数的话必须传递三个参数才能一一对应.
// 对象是有属性名的，属性名对应即可

//命名导出
const $http = (type, url, params) => {
    return axios[type](url, params)
}
export { $http }
```

## 动态组件

当你想要根据一个数据切换不同组件的展示，此时可以使用动态组件。动态组件是由 vue 的自带 component 元素搭配 is 属性代码如下
动态组件的切换方式是属于 v-if 的切换

```html
<!-- currentComponentName属性 的值需要和组件名相同 -->
<!-- 当修改 currentComponentName属性 的时候就会切换不同的组件展示了  -->

<!-- <Home v-show="activeType==='Home'" />
<Posts v-show="activeType==='Posts'" />
<About v-show="activeType==='About'" /> -->
<component :is="currentComponentName"> </component>
```

动态组件搭配 keep-alive 实现动态组件的数据缓存。允许组件有条件的缓存（include,exclude,max）
当动态组件切换的时候每个组件默认都会变成初始状态，假如有的组件内有 data 并且希望 data 修改的时候能够保留，意思就是动态组件切换的时候中间的某个组件的 data 不会被初始化。此时就需要使用 keep-alive

```html
<keep-alive include="Home" exclude="Home" :max="10">
  <!-- includes 属性的属性值可以是字符串或者正则，匹配的组件名才缓存数据 -->
  <!-- exclude 与 includes 相反 -->
  <!-- max 最多缓存的组件实例个数   -->
  <component :is="currentComponentName"> </component>
</keep-alive>

```
还有一种更新title的方法：
```html
父组件
<!-- <component :title="title" @handle-title="handleTitle" :is="activeType"></component> -->
<!-- $event类似于传过来的值， -->
<!-- <component :title="title" @update:title="title=$event" :is="activeType"></component> -->
<!-- 上种方式可以简写成如下： -->
<component :title.sync="title" :is="activeType"></component>
子组件
<!-- <button @click="$emit('handle-title','three')">three</button> -->
<!-- 子组件的update:title,在父组件直接简写成了.sync就行 -->
<button @click="$emit('update:title','three')">three</button>
```