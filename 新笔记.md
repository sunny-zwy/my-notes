#### 基本 shell 命令

需要使用命令行，安装 git bash 即可。

##### ls 命令

查看当前目录下的所有内容

命令参数

- `-a` 查看当前目录下的所有内容包括隐藏文件

##### cd 命令

跳转目录
特殊的目录

- ~ 用户主目录，存储着很多默认配置

##### mkdir 命令

创建文件夹

##### touch 命令

创建文件，需要加后缀名

##### rm 命令

删除文件或文件夹

参数

- -r 删除文件夹
- -f 强制删除

##### pwd 命令

打印当前位置

##### cp 命令

复制或重命名
参数

- -r 可以复制文件夹

##### mv 命令

剪切

##### cat 命令

查看文件里面的内容

###### 安装注意

不需要选择安装目录，一直下一步，直到出现很多复选框其中有两个是 `git bash here` 和 `git gui here` 将后面的勾选掉(不勾选)，继续一直下一步即可。安装完毕之后在任意空白处点击鼠标右键就会出现 `git bash here` 命令。


#### git 的基本操作

#### 本地的项目已经做好了(做了一部分，项目刚开始)，向要传到 github 网站保存

##### 上传到网上非空仓库 (比如 [username].github.io)

- 先将网上的仓库下载到本地，需要使用命令 `git clone 仓库地址`
- 将想要托管的项目放到该仓库内，仓库内不必要的东西删除
- 将本地和网上关联起来(将自己本地的修改上传)
  - 将自己对仓库的所有修改添加到 github 远端记录,执行 `git add .`
  - 将记录好的修改做成版本，执行命令 `git commit -m'留言'`
    - 如果是第一次和 github 关联的话，会失败，然后会提示
      ```shell
        please tell me who you are ?
        让你依次分别执行以下命令
        git config --global user.name "yourname"
        git config --global user.email "youremail"
      ```
    - 告诉他之后再次执行 `git commit -m'留言'`
  - 将新的版本上传，执行命名 `git push`
    - 由于是第一次和网上关联，会失败提示
      ```
        让你执行
        git push -u origin master
        执行完毕之后就成功了
      ```
- 上传成功之后，想要修改的话，直接在本地仓库修改然后执行上传三部曲即可

##### 上传到网上空仓库 (我创建的 first_demo 空仓库)

- 网上传建一个项目同名(你的项目文件夹是什么名字，仓库名与之相同)空仓库(创建的时候不添加 reademe 文件)
- 在你的本地项目文件夹内打开命令行工具
- 将自己本地的项目初始化成 git 仓库，执行 `git init` 命令
- 执行 add 和 commit 命令(简写的需要自己补充)
- 去网上你的空仓库复制代码，第一个提示框的最后两行
  ```
    git remote add origin https://github.com/Sunny-zz/first_demo.git
    这行命令作用是给本地的仓库添加一个远端地址 名称叫 origin 地址是 后面的地址
    git push -u origin master
    将版本上传到已经添加的远端 origin
  ```
- 执行完毕之后上传成功，想要修改的话，直接在本地仓库修改然后执行上传三部曲即可

#### 使用 ssh-key 秘钥

将自己的电脑的当前系统和 github 关联。在上传或下载的时候使用 ssh 方式，省略输入用户民和密码。关联步骤如下

- 打开命令行工具 输入 `cd ~` 命令
- 执行 `ssh-keygen` 命令，生成电脑上的公钥和私钥，直接一直回车直到出现密码图即可。
- 找到生成的公钥和私钥，位置在 `~/.ssh/` 文件夹下，使用 cat 命令打印出公钥内容并复制 `cat .ssh/id_rsa.pub`
  - 如果生成的秘钥名称不是 id_rsa.pub 的话自己去找一下
  - 执行 `cd .ssh` 在执行 `ls -a` 查看自己的秘钥名称
  - 在使用 `cat 你的公钥` 去复制。
- 打开 github 网站，点击头像的下箭头选择 setting，找到 ssh key 新增一个即可。
- 验证 ssh 是否生效的话，需要重新从网上下载(选择 ssh 方式下载)仓库到本地，再次上传更新的时候就不需要输入用户名和密码了。

#### 多个人或者多台电脑对同一个仓库的同一个分支进行操作

- 同事 a 对 first_demo 仓库进行了修改，在 index.html 内添加了 一个轮播图，上传提交成功
- 同事 b 被要求添加一个 about 页面在项目内，做完之后上传执行 git 上传三部曲。执行 `git push` 失败提示远端存在本地不存在的版本，可以使用 `git pull` 命令。
- 执行 `git pull` 将远端的版本拉取到本地，但是本地已经存在了一个为提交的版本，

  当这两个版本不冲突的时候(不时同一个文件，或者同一个文件的不同位置)，

  - git 会自动合并两个版本，并弹出新的命令面板让你提交合并的版本留言，可以直接按住 shift 并按两下 z，退出留言面板。
  - 再次执行 git push，上传更新

  当这两个版本冲突的时候(修改的是同一个文件的同一个位置)

  - git 并不会自动合并，而是将冲突体现在当前的文件内，需要用户自己选择保留哪个更改，选择完毕之后，使用 git 上传三步提交。

#### github 的分支操作

一个仓库内可以有多个分支，默认只有一个分支 master ，通常称为主分支(用来放合并后的代码)。也可以创建无数个其他分支。一般工作流程是先在主分支将项目的主体框架搭建完毕，然后创建多个分支，每个分支代表不同的功能，不同的程序猿分别在不同分支内进行开发，开发完毕将代码合并到主分支。

- 创建一个仓库(breach_demo)带上 readMe ,然后克隆到本地，添加上公共的 css 和 js 然后上传。
- 创建新的分支 a 和 b，使用 `git branch a` 和 `git branch b` 命令。分支创建的时候里面的内容和主分支是一模一样的。
- 需要将创建好的分支上传到网上，可能直接使用 `git push` 就会成功,但是由于网上并没有新分支，所以需要使用 `git push --set-upstream origin yourbranch` 上传。
- 现在本地和网上同步(三个分支都同步了)，接下来就可以分开工作了。
- 分别切换到 a 分支和 b 分支，展开自己的工作，创建新的页面并上传。
- 主分支分别合并两个分支的内容，然后上传。需要使用 `git merge yourbranch` 命令合并分支。合并之后上传。

#### github 的特殊分支 gh-pages

拿我们创建好的 branch_demo 仓库来说，mater 分之内已经存放好了其他分支做好的项目(项目成品，包括 index...),github 仓库有一个特殊的分支叫 gh-pages ,该分支下的内容会被自动托管到 github 免费服务器(也就是说只要该分支下有 index.html 就可以直接使用网址访问)
只需要直接创建 gh-pages 分支，并上传到网上即可。

#### 仓库根目录下的 .gitignore 文件

gitignore 文件是一个隐藏文件，该文件的作用是当你将一些文件或文件夹的名称写在 .gitignore 内的话，该仓库执行上传操作的时候，会忽略 .gitignore 内添加的文件或文件夹

#### git 常用命令

- `git --version` 查看 git 版本号,有时候可以简写成 `-v`
- `git clone 仓库地址` 克隆仓库到本地
- `git add .` 将你的修改让远端记录 . 代表所有的修改 也可以换成文件名
- `git commit -m'留言'` 将记录好的修改做成版本,并提交版本留言
- `git push` 将做好的版本提交到远端
- `git init` 将本地项目变成仓库
- `git status` 查看当前仓库的状态
- `git log` 查看本地版本
- `git pull` 将远端的更新拉取到本地
- `git branch newBranch` 创建新分支
- `git branch` 查看分支
- `git checkout yourbranch` 切换分支
- `git merge yourbranch` 当前分支合并分支其他分支
- `git pull origin master` 拉取主分支上的更新
- `git checkout -b newbranch` 创建新的分支并切换过去

#### 注意

- 仓库不能嵌套仓库
- 版本回退

#### 类似 github 网站的其他工具

- 腾讯云开发者平台,是一个和 github 类似的网站，服务器是国内的操作起来很快。
- 码云 一般从 github 下载项目，可以通过 码云 下载

#### ECMAScript 6 es2015 新 js(ES6)

##### const 和 let

let const 和 var 的不同

const 是声明常量(值不可修改，例如 π)的,常量的名称都是全大写的（单对于const）

- 不能重复声明(同一个变量声明两次就报错,而var第二个覆盖第一个)
- 没有声明提升(先console,在赋值，var会显示undefined。但是let，const就错误提示)
  ```js
  console.log(num);
  var num = 10
  // 如果没有定义num，直接log,就提示 num is not defined
  ```
- 存在块级作用域(作用域被定义在 {} 内)
  ```js
  for (let index = 0; index < 10; index++) {
  }
  console.log(index)
  // var：11
  // let： index is not defined
  // const：出错，因为不能修改const定义的数

  ```


let 声明的变量是可以被修改的

##### 变量的解构赋值

对象解构赋值

```js
const obj = {
  username: '貂蝉貂蝉',
  userage: 18,
  level: 10,
}
const { username, userage: age } = obj
console.log(username, age)
// 貂蝉貂蝉,   18
```

字符串的解构赋值

```js
const str = 'hello vue'
const [d, e, f] = str
console.log(d, e, f)
// h e l
```

数组的解构赋值

```js
const arr = [1, 2, 3, 4, 5]
const [a, b, c] = arr
console.log(a, b, c)
// 1 2 3
```

函数参数的解构赋值

```js
const obj = {
  username: '貂蝉',
  userage: 18,
  level: 10,
}
function showInfo({ username, level }) {
  // const { username, level } = obj
  console.log(`该英雄的名称是${username}`, `等级${level}`)
}
showInfo(obj)
```

技巧: 实现变量调换

```js
let x = 1
let y = 2

[x, y] = [y, x]
```
const 的小应用
```js
const obj = {
  name: '吕布',
  age: 28,
}
obj.level = 15
// 这样能加进去，因为const obj是地址，而改的是地址里面的东西，地址没变
```
```js
const obj = {
  name: '吕布',
  age: 28
}
obj = {
  name: '吕布',
  age: 28,
  level=18
}
//这样就会报错，因为地址已经改了。
```
##### 字符串的扩展

模版字符串

```js
const username = 'lucy'
console.log(`my name is ${username}`)
```

新增的字符串方法
includes(), startsWith(), endsWith(), trimStart(),trimEnd(),padStart(),padEnd(),matchAll()

##### 函数的扩展

函数参数的默认值
普通方式参数非对象

```js
// 函数参数的默认值，默认有值
const fun = function (color = '黑色', bgColor = '红色') {
  console.log('颜色:::', color)
  console.log('背景色:::', bgColor)
  // 蓝色   红色
}
fun('蓝色')
```

参数为对象

```js
const fun = function ({ color = '黑色', bgColor = '蓝色' }) {
  console.log('颜色:::', color)
  console.log('背景色:::', bgColor)
  //  粉色   蓝色
}
fun({ color: '粉色' })
// 不能什么都不传，最起码传递一个空对象
```

rest(剩余) 参数
<!-- 遗留一个arguments语法 -->
```js
function add(a, b, ...rest) {
  // 用 ... 后面加变量，指的就是剩余的参数
  console.log(a, b, rest)
  // 1  2   [3, 4, 5, 6, 7, 8, 9, 10]
  // rest 是数组
}
add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

箭头函数写法（省略了function）

  ```js
  
  ```
- 箭头函数定义只能变量式定义，
- 箭头左边是 函数的参数部分 使用小括号包裹参数逗号拼接,当参数只有一个的时候可以省略小括号
  ```js
  const add = num1 => num1
  ```
- 箭头右边是 函数主体，使用花括号包裹，返回值设置依然使用 return。当函数不需要操作就设置返回值的话可以省略花括号和 return 直接写返回值即可
```js
// 1.
const add = (num1, num2) => {
  return num1 + num2
}
// 2.
const add = (num1, num2) => num1 + num2
// 调用
const res = add(10, 20)
console.log(res)
// 30
```

箭头函数和普通函数的区别

- 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
```js
var username = 'window'
function xx() {
  var username = 'local'
  console.log(this.username)
  // window ,因为是window调用的xx，谁调用的，this指谁
}
xx()

const obj = {
  name: 'lily',
  say: () => {
    console.log(this.name)
    // 是空的，因为箭头函数里的this指得使用时的组件
  },
}
obj.say()

const obj = {
  name: 'lily',
  say: function () {
    console.log(this.name)
    // 显示lily，因为调用的是obj，普通函数里this指的是当前组件obj
  },
}
obj.say()
```

- 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

##### 数组的扩展

Array.from(): 将类数组转化为数组

```js
const fun1 = function () {
  // arguments算是一个类数组
  console.log(arguments)
  // [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]
  console.log(Array.from(arguments))
  // [1, 2, 3, 4]
}
fun1(1, 2, 3, 4)

// 类数组和对象类似，大概如下：
const obj = {
  // 前面属于下标，必须按顺序写，不然就undefined
  '0': 12312,
  '1': 98768,
  // 这是长度，必须写对，否则多出来的undefined
  length: 2,
  // 这写随便其它的变量
}
console.log(Array.from(obj))
// [12312, 98768]
```

Array.of(): 将几个数变成数组

```js
  const num1 = 11
  const num2 = 111
  const num3 = 111
  const num4 = 112
  const arr = Array.of(num1, num2, num3, num4)
  console.log(arr);
  // [11, 111, 111, 112]
```

数组新增方法 flat，flatMap

##### 扩展运算符

作用是对象的拷贝，还有类数组转化数组

- 对象展开
- 数组展开

```js
const obj = {
  name: '庄周',
  age: 18,
}
const obj1 = { ...obj }
obj1.hobby = '浪'
console.log(obj, obj1)

const arr = [1, 2, 3]
const arr1 = [...arr]
arr1.push(4)
console.log(arr, arr1)
```

##### 对象的扩展

对象的简洁表示法

```js
const username = '哈哈'
const userage = 20
const obj = {
  username,
  // 当对象的属性名和作为该属性的属性值的变量名相同时
  userage,
  // 函数可以省略 function，是普通函数
  say() {},
}
console.log(obj)
```

##### Symbol

第七种数据类型，生成独一无二的数据

##### set 数据结构

类似于数组，但是不能存重复的值

```js
const ary = new Set([1, 2, 131, 312, 1, 2, 131])
console.log(ary)
// 属性
// size
console.log(ary.size)
// 方法
// add() 向set数据内添加一个成员,返回数据本身
ary.add(1000)
console.log(ary)
// delete() 删除某个值，返回一个布尔值
//  has() 查看该值是否为Set的成员，返回一个布尔值
// clear() 清除所有成员
// 如何将 set 数据转化成数组
console.log([...ary])
```

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- Set.prototype.keys()：返回键名的遍历器
- Set.prototype.values()：返回键值的遍历器
- Set.prototype.entries()：返回键值对的遍历器
- Set.prototype.forEach()：使用回调函数遍历每个成员

还有一个额外的 WeakSet 数据结构,内部成员只能是对象类型

##### class 类

写法

```js
class Hero {
  // 类的花括号内默认一般只写方法，而且方法之间不需要逗号
  // constructor 是 class 自带函数，该函数被称作构造器和以前的构造函数类似
  // constructor 函数当 创建实例化类的时候自动触发
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  // 除了 constructor 函数之外定义的函数都相当于原来的 prototype 内的方法
  say = () => {
    console.log('我是王者荣耀的英雄' + this.name)
  }
}
const a = new Hero('牛', 20)
const b = new Hero('小乔', 18)
console.log(a)
console.log(b)
a.say()
```

继承

```js
class CarryHero extends Hero {
  constructor(name, age) {
    super(name, age)
    // super 调用了才真正实现了继承
  }
}
const c = new CarryHero('赵云', 19)
console.log(c)
```

#### node

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。
安装
直接百度 node 进入中文网直接下载安装包，直接进行安装不需要做任何的选择，一直下一步即可。
任意位置打开命令行工具，输入 `node -v` 和 `npm -v` 查看 node 和 npm 的版本号，如果有就安装好了,如果命令出错尝试重启电脑再次执行。

npm 是什么
安装好 node 之后 npm 就附带安装好了。他是 node package manager,node 包管理工具。

node 模块(后台，前端)

前端模块包括前端所有的 js 相关的包。

node 模块使用

- 新建文件夹，将该文件夹初始化为 node(npm) 的项目执行 `npm init -y`
- 新建 index.html 页面
- 安装 jquery 插件。执行 `npm install jquery`
- 安装完毕之后，项目内多了点东西
  - node_modules 文件夹，该文件夹是存储下载的包的地方
  - package-lock.json 文件，该文件是记录安装的包的详细信息的，不需要理会
- 在 html 中使用 jquery 可以按照之前的路径导入(不推荐)。但是现在是使用 npm 下载模块。可以使用 node 模块的方式导入安装好的包。 使用 `require(包名)`
- 但是当做模块导入之后浏览器报错。因为模块语法浏览器不支持需要编译。

npm 的使用
npm 就是下载 node 包的工具。
下载方式有三种

- `npm i 包名 --save`，这种方式一般下载的是项目的必须依赖,记录到 package.json 内的 dependencies 字段内。
  ```
    npm install jquery@2.3.4 --save
    npm i jquery -S
    npm i jquery
  ```
- `npm i 包名 包名 --save-dev`,这种方式安装的是项目的非必须依赖(工具类),记录到 package.json 内的 devDependencies 字段内
  ```
    npm install webpack --save-dev
    npm i webpack -D
  ```
- `npm i -g 包名`,这种方式是全局安装，当你想要在你的电脑上任何地方都使用包的时候进行全局安装。
  ```
    npm i -g server
  ```

卸载包使用 `npm uninstall 包`通过哪种方式安装的就怎样卸载。

npm 下载包的好处

- 可以使用模块导入
- 下载的包的信息全部记录在 package.json 内
- 同事之间相互传递项目的时候不需要传递 node_modules 文件夹。使用的时候只需要执行 `npm i` 命令会重新将所有的包下载一遍。

npm 的技巧，直接在任意位置的命令行执行即可

- 切换 npm 包的来源，默认的来源是外网服务器有点慢
  ```
    npm config set registry https://registry.npm.taobao.org
  ```
- 加上 http 显示配置，不让等待过程显得无聊。

  ```
    npm config set loglevel=http
  ```

提示：如果想在命令行里查看js浏览器中不支持的require，用 $ node 路径（$ node ./js/...），要想让浏览器认识，可以通过webpack编译
#### node 模块语法
- 前端模块分类 ：核心模块 第三方模块 自定义模块
- 模块导入： require('包名') 前两种模块直接写包名 自定义模块需要写路径
- 模块导出: module.exports={值}
(提示：没写{}默认导出第一个值，写了{}，那么两个都有或者 a:66)
#### 使用 webpack 打包编译我们的项目

你的 node 项目内使用 node 模块导入各种依赖，webpack 可以实现将模块的导入导出编译成浏览器认识的语法，也可以将所有的导入模块操作打包。
如何使用 [参考链接](https://www.webpackjs.com/guides/)

- 项目内安装 webpack
  ```
    npm install webpack webpack-cli  --save-dev
  ```
- 将 js 文件夹的名字改成 src，保证项目的根目录有 src ，并且 src 下存在 index.js，还有 index.js 是页面的主要用的 js
- 执行编译打包命令 `npx webpack`，会将 index.js 打包编译到项目下的 dist 文件夹下的 main.js
- 页面导入打包好的 js
- 上面是使用了 webpack 的默认配置进行的打包，可以在项目根目录下新建 `webpack.config.js` 文件，当作 webpack 编译的配置文件。参考网址 `https://www.webpackjs.com/guides/getting-started/#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6`,复制基础的配置到该文件内。
- 一直敲编译命令很繁琐，可以使用 package.json 中的 scripts 字段配置'快捷键'。使用 npm run 名 快捷执行。
  (提示：在package.json下的scripts里输入的 `"build": "npx webpack --config webpack.confi.js"`)

#### module

es6导入两种方式

- 默认导入
- 命名导入

导出两种种方式

- 默认导出
- 命名导出

#### es6 模块写法
// 模块路径 第三方和核心模块直接写包名

- 默认导入：`import x from "./index.js"`
- 默认导出: `export default a;`
- 默认导入和默认导出的名字可以不一样（x,a）,默认导出只能导一次，也只能导一个变量
```js
  //默认导入
  import x from "./index.js"
  import $ from "jquery"
  //默认导出a
  export default a
```
- 命名导入：`import xxx, { a as x, b } from "./about";`
            `import * as obj from "./about";`
- 命名导出：`export const a = 100;`
- 命名导入名字必须和导出一致，可以使用 as 换名
- 命名导出和默认导出可以同时存在,命名导出可以使用多次
- 全部导入不管是默认的还是命名的 obj 内存在所有的导出
- xxx 代表默认的，{}内代表命名的

#### ajax

Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）.
在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
现在已经进阶了，进阶成 Asynchronous JavaScript and JSON。

##### 原生 ajax

- 创建 xhr 对象
- 使用对象创建请求
- 使用 send 发出请求
- 使用 onreadystatechange 函数监听请求的过程，获取响应

```js
// get
const xhr = new XMLHttpRequest();
// 创建请求  open('请求的类型','地址','是否异步')
// 请求的类型 后台规定的
// GET  POST  PUT  PATCH DELETE ...
xhr.open("GET", "http://jsonplaceholder.typicode.com/posts", true);
xhr.send();
// 监听整个请求过程
// xhr.readyState 请求状态 0-4    4请求成功响应就绪
// xhr.status 请求状态码  200 ok
// xhr.responseText 返回的数据
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 可以获取后台数据
    console.log(JSON.parse(xhr.responseText));
    // 获取到的数据类似数组字符串   ---> json 串
    // 属性名和属性值必须使用双引号，数字和布尔值不需要，最后一项没有逗号
    // 使用 JSON.parse(json串) 转换
  }
};
// post 请求 类似登录
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://cnodejs.org/api/v1/accesstoken", true);
// 发送请求的时候需要传递给后台数据
// 但是原生 ajax 不能接收对象为参数，只能接收 json 串,而且得设置请求可以传递 json
// 需要使用 xhr.setRequestHeader() 设置请求头
// 添加 json 为可传递数据,使用 JSON.stringify 将对象转化为 json 串
xhr.setRequestHeader("Content-type", "application/json");
xhr.send(
  JSON.stringify({ accesstoken: "ecf878d1-6052-476a-8262-824760c7872b" })
);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  }
};
```

##### jquery ajax
- get 请求
- $.get(地址,参数,回调函数,返回内容的格式)
- 地址 后台接口地址
- 参数 请求的参数，不需要可省略
- 回调函数  成功之后的回调函数默认接收一个参数就是返回的结果
- 返回内容的格式  默认带 json 不需要设置
```js
$.get("http://jsonplaceholder.typicode.com/posts", function (res) {
  console.log(res)
  });
```
- post 请求
- $.post(地址,参数,回调函数,返回内容的格式)
- 参数的意思和 get 一致
```js
  $.post(
        "https://cnodejs.org/api/v1/accesstoken",
        { accesstoken: "ecf878d1-6052-476a-8262-824760c7872b" },
        function (res) {
          console.log(res);
        }
   );
```

常用方法 `$.ajax({配置对象})`

```js
// get（默认 type 是 get,不区分大小写）
$.ajax({
  type: "get",
  url:"http://jsonplaceholder.typicode.com/posts",
  success: function (res) {
    console.log(res);
  },
  // 请求失败的回调
  error: function (err) {
    console.log(err);
  },
})

//post
$.ajax({
  // 请求类型
  type: "POST",
  // 请求地址
  url: "https://cnodejs.org/api/v1/accesstoken",
  // 请求参数
  data: { accesstoken: "ecf878d1-6052-476a-8262-824760c7872" },
  // 请求成功的回调
  success: function (res) {
    console.log(res);
  },
  // 请求失败的回调
  error: function (err) {
    console.log(err);
  },
  // 请求结束的回调，无论是成功还是失败
  complete: function () {
    console.log("完事")
  },
  // 发给后台的内容类型 默认支持 对象类型
  // contentType: ""
  // 请求是否同域 false 代表同域请求  true 代表跨域请求
  // 一般来说后台独立解决了跨域请求的问题，不需要前端进行配置
  // 也有前后端一起解决跨域问题，后台需要前端做一些简单的配置
  // crossDomain: 布尔值
  // headers: 请求头的设置  可能需要配合后台做一些设置
});
```

请求的地址：`http://localhost:3008/posts?id=1`（自己建的）
```js
// 地址栏的问号部分就是查询部分
$.ajax({
  // url: "http://localhost:3008/posts?_limit=10&_page=1",
  //上面url和下面的两个是一样的，可以把？后面的查询部分写在data里
  url: "http://localhost:3008/posts",
  data: { _limit: 10, _page: 1 },
  success(res) {
    console.log(res);
    //结果拿到的是对象，后面加上.data就变成数组了
  }
});
```
      
##### axios ajax
axios 是专门的 ajax 请求插件，它里面的异步解决方案使用的是 promise。文档参考[网址](https://www.kancloud.cn/yunye/axios/234845)，axios的有点复杂的介绍[网址](https://www.kancloud.cn/yunye/axios/234845)
- 异步非阻塞
- 同步阻塞

```js
// get
axios
  .get("http://localhost:3008/users", {
    params: {
      _limit: 20, _page: 2
    },
  })
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.log(error);
  });
// axios 就是使用 promise 封装了异步操作
// axios.get('地址').then(res=>{}).catch(err=>{})
// then 是成功函数  res 是成功的返回值  axios 会将后台的数据存储到一个对象的data属性内


// post
axios
  .post("https://cnodejs.org/api/v1/accesstoken", {
    accesstoken: "ecf878d1-6052-476a-8262-824760c7872b",
  })
  .then(res => {
    console.log(res.data);
  });
```
异步同步的小例子
```js
setTimeout(() => {
    // 异步完毕之后执行的事
    console.log("异步完毕");
  }, 1000);
  console.log(1);
  // 嵌套很多的回调，一旦某一环节需要做额外的判断处理
  // 回调地狱
  $(".box").slideDown(1000, function () {
      $('.bxo')
  });
```
promise（把异步操作放在promise里的小例子）
```js
//第一种简单的小例子
let num = 10;
console.log("正在干活计数");
const promise = new Promise(function (resolve, reject) {
  // resolve 函数的意思就是成功的回调函数
  // reject 函数的意思就是失败的回调函数
  setTimeout(() => {
    num = 100;
    if (num === 100) {
      console.log("活干完了");
      resolve();
    } else {
      console.log("有点问题没做完");
      reject();
    }
  }, 1000);
});
// .then 就是传递 resolve 函数
// .catch 就是传递 reject 函数
// 避免了回调嵌套
promise.then(function () {
  console.log("计数完成了，进行下一步操作");
});
promise.catch(function () {
  console.log("没干完，得继续干");
});

//第二种一般这样使用的小例子
function timeout(ms) {
  return new Promise((resolve, reject) => {
    console.log("异步操作正在执行");
    setTimeout(resolve, ms, "done");
  });
}

timeout(1000).then(value => {
  console.log("执行完毕之后做的事");
  console.log(value);
  //value的值是done，详解如下一个js
});
```
```js
setTimeout(
  (value, value1) => {
    console.log(value, value1);
  },
  1000,
  1,
  2
);
// 输出1 2，具体为什么自己想,hahaha 
```
##### 使用 json-server 模拟后台数据库

- 全局安装 json-server `npm i -g json-server` 可能有点慢,安装一次就够了
- 在需要的地方新建 xxx.json 文件,还文件内写法如下
  ```json
  {
    "users": [
      {
        "id": 121,
        "username": "小王"
      },
      {
        "id": 21,
        "username": "小二"
      }
    ]
  }
  ```
- 这样的 json 文件生成的数据代表 users 列表数据
- 数据列表中最后不能加逗号，可以写多个列表数据（接口）
- 接口文档的值必须是对象或数组（users是一个接口，可以有多个接口）
- 在该 json 文件所在的地方打开命令行工具，启动数据库服务。`json-server --watch xxx.json -p 3000`，命令执行完毕之后，数据库就启动了，不要关闭该服务。安装上述 json 文件，启动的服务可以使用 'http://localhost:3008/users' 接口就能访问用户列表了。
- 更详细的接口文档说明参考[json-server](https://github.com/typicode/json-server)(就是去掉接口名)

##### 将自己的项目跑在本地服务器上

- 全局安装 serve `npm i -g serve`,安装一次就够了
- 在你的项目内打开命令行工具执行 `serve .`
- 执行完毕之后你的当前项目内的所有文件已经被跑在了 `http://localhost:5000` 服务器上，默认打开 index.html

##### 项目服务器

项目的开发阶段，前端页面跑在本地(局域网)服务器上，后台数据库服务器只能公司内部访问。

# vue 框架
## vue安装

想要使用 vue 开发项目，需要安装 vue 的开发环境。官方网站提供了安装环境的脚手架工具 vue-cli。使用命令 `npm install -g @vue/cli` 全局安装脚手架工具。工具安装好之后就可以搭建 vue 的开发环境了。有两种方式搭建

- vue create 命令，在想要创建项目的文件夹下执行 `vue create 项目名`。
- 图形化界面工具。任意位置执行 `vue ui` 在浏览器中调出图形化界面，创建 vue 项目。
  - 选择上方的创建按钮
  - 选好项目所要创建的位置
  - 选择默认的预设模版
  - 创建
  - 创建完成之后，选择 任务-->serve-->运行-->启动 app
  - 运行还可以使用命令：npm run serve
  - 此时 vue 的基础项目已经搭建完毕。

## vue 初始项目结构

- node_modules 该项目依赖包的存放位置
- .gitignore 作为 github 仓库忽略上传的记录
- package.json 记录了 node 项目的基础配置，和一些 vue 项目的配置
- package-lock.json 详细记录项目所用到的包
- README.md 项目介绍文件
- public 该文件下存在的是项目的 html 模版,意思就是你写的所有的 vue 代码其实都是以该模版为基础的，一般不需要修改，偶尔可能会引入一些文件(css js 等工具类的)
- babel.config.js babel 的配置文件，babel 是一个 js 编译工具，作用是编译新版本的 js 语法。
- src 文件夹是 vue 项目的源代码
  - assets 存储静态文件的文件夹，一般存放一些 公共的 css 图片等
  - components 存放 vue 组件的，文件夹名称可以修改
  - app.vue 该文件就是 vue 的最外层组件
  - main.js 该项目的入口文件，意思是 webpack 会将该文件打包编译。该文件内写的是 vue 一些全局设置。

## spa 单页面应用

vue 项目创建的就是单页面应用。整个项目就在一个页面内。参考文档[单页面](https://www.jianshu.com/p/0c32c85c668b)


## vue 组件

整个 vue 项目就是由各种各样的组件组合而成的。组件可以理解成我们原来排版的某一个结构部分。app.vue 组件是项目的最外层结构。在 vue 项目中，最简单的组件写法就是以 vue 为后缀名的文件，组件名称一般首字母大写，多个字母使用大驼峰方式命名。
如何划分组件，其实就是和之前画盒子一样。
vue 后缀的组件构成

- html 部分，使用 template 标签表示，里面写 html 即可，也可以嵌入其他的组件，需要注意的就是该 template 标签只能有一个子级
- script 组件的 js 部分。自己页面的逻辑处理，其他组件的注册。
- style 组件的 css 部分，默认的样式是全局的。

## components 的作用

## main.js 的作用
```js
import Vue from "vue";
// 导入 Vue
import App from "./App.vue";
// 导入 最大组件 app
import "./assets/style.css";
// 导入全局的 css
Vue.config.productionTip = false;
// Vue 项目的配置去掉生产版本提示
// 现在是开发阶段，看不到打包之后的代码，打包之后的代码被托管到服务器上，所以我们可以通过访问服务器地址访问我们的项目
new Vue({
  render: h => h(App)
}).$mount("#app");
// 创建 vue 实例 添加render配置，作用是需要渲染的组件
// 实例创建好之后使用实例的 $mount 方法将实例挂载到页面的 #app 结构内
```
## 整理初始项目(删除一些内容)

App.vue 只剩下

```js (vue)
  <template>
    <div id="app">hello world</div>
  </template>

  <script>
    export default {
    name: "App"
  };
  </script>

  <style></style>
```

删除 HelloWorld 组件

## 组件样式

组件的样式基本上都是全局的，因为只有一个页面，所有的组件都会渲染到同一个页面。

- 在 style 标签上加上 scoped 属性，使组件样式私有化
- 在 style 标签上加上 lang 属性，可以设置使用高级 css 扩展语法(less sass)

## 组件的嵌套

1. 先在父组件内导入子组件
2. 在父组件内的导出对象内使用 components 属性先注册子组件。

  ```js （app.vue）
  <script>
   // 第一步，先在父组件内导入子组件
    import Header from "./components/Header";

    // 在组件内js部分必须默认导出一个对象，而且该对象下一般必须设置一个属性 name 属性值可以和组件名一致，不能和 html 标签命名冲突
    export default {
      name: "App",
      // 第二步 组件注册
      components: {
        // Header: Header,
        // 对应的是在wrap里引用的那个：上面导入的变量
        Header,
      },
    };
  </script>

  <style scoped>
  // scoped 的作用就是给该组件的所有标签加上一个随机属性(和所有组件都不同)，所有选择器都添加上了该属性的属性选择器
  // 那么加了 scoped 属性的样式就变成了私有样式了 
  </style>

  ```

3. 在父组件的 template 内直接使用组件名称的标签即可
  ```html
  <div class="wrap">
    <header />
    <!-- header 名字任意起的 -->
  </div>
  ```

## 组件的复用技巧 props

当一个组件需要在很多个组件内使用，而且多多少少显示的内容不一样，其实是需要根据组件所在位置进行轻微的修改。此时就可以借助 vue 内的 props 知识点处理。
父组件嵌套子组件的时候希望子组件要根据我的想法修改一些内容。
props 的使用
1. 在父组件内，直接当做自定义属性传递即可

```html
<Button value='warning' text="Download Now" color="#00f" :isActive="true" />
```

2. 在子组件内，需要使用导出对象下的 props 属性接收
方式一数组

```js
export default {
  name: "Button",
  // 接收的时候使用字符串  数组方式
  props: ["text", "color"]
};
```

方式二对象

```js
export default {
  name: "Button",
  // 对象方式 高级可以做简单的校验
  props: {
    text: {
      //  可以设置属性的类型和默认值
      type: String,
      default: "default button"
      // required: true,
      //必填的字符串，和default冲突,两个一起写default生效，但还是会提示红色错误
    },
    isActive: {
      type: Boolean,
      default: false
    },
    value: {
      type: String,
      default: "success",
      // 可以自定制匹配校验
      validator: function (value) {
        // value 代表的就是父组件传递的值
        // 这个值必须匹配下列字符串中的一个,能执行，但也出现红色错误
        return ["success", "warning", "danger"].indexOf(value) !== -1;
      },
    },
  }
};
```

3. 接收完毕之后需要在 template 中使用，使用方式分为**两大类**

- 在标签的尖括号之间使用，直接用双花括号嵌套 props 名称即可

  ```html
  <button class="btn">{{text}}</button>
  ```

- 在标签的属性内使用,需要使用 vue 指令 `v-bind:` 也可以直接省略使用 `:`

  ```html
  <!--  语法就是 v-bind:属性名='这里面直接写js即可'  v-bind: 可以简写成 : -->
  <!-- <button :style="'background-color:'+bgColor " class="btn"></button> -->
  <button :style="`background-color: ${color}`" class="btn">按钮</button>
  ```

## vue 的模板语法

我们在介绍 prop 的时候就已经使用了 vue 的模板语法。在 template 中嵌入 js。
分为两大类

- 在标签的尖括号之间使用，直接用双花括号嵌套 props 名称即可
- 在标签的属性内使用,需要使用 vue 指令 `v-bind` 也可以直接省略使用 `:`

## 复用技巧的小整理：

1. 只要是在 template 想要使用 js 的话都遵循两个语法，也就是以上**两大类**
2. v-bind:属性名='这里面直接写js(只能是值或者运算不能是语句)即可
3. `<button :class="`btn ${isActive ? 'color' : ''}`"></button>`

## vue 组件的 data

- 只要是组件的 html 内容(结构，样式...)发生改变的话，那么这个改变必须由 data 内的某个 数据 控制。
- 之前想要点击按钮修改颜色，必须获取真实的 box 的 dom 节点，然后修改
- 其实上述方案可能会导致浏览的重排和重绘
- vue 为了解决上述问题使用的 虚拟 dom 的概念
- 页面的所有的变化必须由组件的 data 的改变而变化

使用方法

1. 需要将变化对应的内容设置成 data
  ```js
  export default {
    name: 'App',
    data: function () {
      return {
        bgColor: 'red',
      }
    },
    ...
  ```
2. 将 data 应用到页面中，使用的时候就相当于一个变量
```js
div v-bind:style="`background-color:${bgColor}`" class="box">
  <button>单机变蓝</button>
</div>
```
3. 使用 js 逻辑修改对应的 data 页面自然就会跟着变化了

- data 的使用
  - 在 template 中使用直接当成变量，使用模板语法写到标签内即可
  - 在 script 内使用的时候要用 `this.名` 访问
- data 的修改
  - 在 template 中的函数内直接对 data 赋值即可
  - 在 script 函数内使用 `this.名` 重新赋值,这种表较常用

## vue 组件内的事件绑定

直接使用 v-on 指令绑定事件，也可以简写成 @ ,vue里没有hover事件，可以写成mouseenter事件

```html
<button v-on:click="change()">单机变蓝</button>
<button @click="change()">单机变蓝</button> 
 <!-- @事件类型='事件函数(可以使 methods 内设置的，也可以是直接写的)' -->
<!-- 所有vue指令的值的引号内都可以直接写 js 语法 ，@click就算是一种指令，后面的值里可以用js -->
<!-- 以上需要写methods对象，以下不需要写methods对象  -->
<button @click="function(){bgColor='blue'}">单机变蓝</button> 
<button v-on:click="()=>{bgColor='blue'}">单机变蓝</button>
 <!-- 事件函数内只要有修改 data 的操作，那么上述写法可以直接简化成： -->
<button v-on:click="bgColor='blue'">单机变蓝</button>

```

```js
<span>成绩：{{grade}}</span>
<br />
// 由于函数没有返回值所以update(190)的返回值是undefined，而vue指令的功能可以这样写，还可以写成： -->
// <button v-on:click="function(){update(200)}">修改成绩</button> -->
// 以上 function是事件函数，update是普通函数 -->
// 没有function函数，update无论有参没参都是事件函数 -->
// 只要是事件函数就有event参数，可以直接用 -->
<button v-on:click="update(190)">修改成绩</button>
```

change 是一个函数名，该函数必须声明在，组件导出的对象下的 methods 属性内，注意的是 这里面的函数在 template 内使用的时候直接使用方法名，而在 script 中使用的时候需要使用 `this.方法名`

```js
  methods: {
    // 该对象下的属性需要写成函数，这个函数可以直接当作事件函数，也可以当作普通函数
    change() {
      this.bgColor = 'blue'
    },
    update: function (value) {
      // update: () => {
      // console.log(this.grade)
      // 箭头函数：Cannot set property 'grade' of undefined"
      //箭头函数和普通函数的this指向不一样，所以箭头函数出错
      this.grade = value;
      console.log(this)
      // 普通函数的 this 指的是组件实例，指的就是这个组件本身
      // 我们可以直接通过 this 能访问到  组件的 data methods  props ...
      console.log(event);
      // 这个事件函数不用传参，直接能用,event显示一个mouseEvent的对象，这个event是从事件函数那来的
    },
  },
```

## 组件间的通信

爷孙组件

- 把del方法使孙子用，爷组件用:delete="del"，儿子接收@delete='delete'，孙子直接用 @click="delete"
- 需要注意，不能用delete关键字，以上我懒的改了！

父子组件

- 使用 props，props 一般用来传递值,也可以传递函数(一般不使用)
```html
<Span :slide1="slide" text="asdsdfsf" />
```
- 自定义事件， 向子组件传递函数，一般是当父组件的 data 想要让子组件修改时使用
- 给子组件设置 ref
    
    父组件中
    ```html
    <!-- content是组件名 -->
    <Content ref="ceShi" />
    <button @click="handle">测试ref</button>
    ```
    ```js
    handle() {
      this.$refs.ceShi.xxx();
    },
    ```
    子组件中
    ```js
    xxx() {
      console.log(111);
    },
    ```
- 子组件也可以传递给父组件函数让父组件使用

  子组件内
  ```html
  <button @click="$emit('add',clearInput)">按钮</button>
  ```
  ```js
  methods: {
    clearInput() {
      console.log(111)
    },
  },
  ```
  父组件内：
  ```js
  methods: {
    add(callBack) {
      //在add里用的时候当作函数调用
      callBack()
    },
  }
  ```

- 父组件内使用 $children 可以获取所有子组件的实例组成的数组
  ```js
  //只能在mounted里log，因为mounted渲染完毕了。
  mounted() {
    console.log(this.$children[0]);
  },
  ```
- 子组件内使用 $parent 获取父组件实例
  ```html
  <!-- 也可以不传props直接使用，但是推荐用props。 -->
  v-for="item in $parent.shuJi"

  <!-- 直接使用爷爷的事件： -->
  <button @click="$parent.$parent.del(shuJi.id)" 
  ```
  ```js
  mounted() {
    console.log(this.$parent);
  },
  ```
- 插槽(slot)
  1. 默认插槽
  ```html
  <!-- 父组件 App-->
  <Button v-model="isActive">哈哈哈</Button>
  <!-- 子组件Button ，用stot接收，页面直接显示 哈哈哈-->
  <button>
    <slot></slot>
  </button>
  ```
  2. 具名插槽
  ```html
    <!-- 具名插槽 v-slot:list 可换成#list  ,父组件App-->
    <template #list>
      <div class="list">列表</div>
    </template>  
    <!-- 子组件Container，主要用来做布局的，可以用以上方式来命名分类，接收用name接收 -->
    <div>
      <slot name="list"></slot>
    </div>
  ```
  3. 作用域插槽
  ```html
    <!-- 为了让子组件的内容在父组件的插槽中使用： -->
    <slot v-bind:obj1="obj" />
    <!-- js里定义了对象 obj -->
    <!-- 以下是父组件中，接收的是obj1 -->
    <ScopedSlotDemo>
    <!-- 可以把以下换成 slot-scope="{ obj1 }"，但是slot-scope马上就被废弃了-->
      <template v-slot:default="slotProps1">
        <span>{{ slotProps1.obj1.age }}</span>
      </template>
    </ScopedSlotDemo>

    <!-- 独占默认插槽简写如下，也可以去掉:default -->
    <ScopedSlotDemo v-slot:default="slotProps">
        <span>{{ slotProps.obj1.age }}</span>
    </ScopedSlotDemo>

    <!-- slotProps 接收的是一个对象，可以解构 -->
    <ScopedSlotDemo v-slot:default="{obj1}">
      <span>{{ obj1.age }}</span>
    </ScopedSlotDemo>
  ```

- 子组件想要修改父组件的内容，类似 sync，语法如下：

  父组件内:把obj全部的属性传给子组件
  ```html
  <Son v-bind.sync="obj"></Son>
  ```
  ```js
  data() {
    return {
      obj: {
        a: 10,
        b: 100,
      }
    };
  },
  ```
  子组件内：可以接收obj对象的全部属性或部分属性，用update进行修改，改成了111
  ```html
  <button @click="$emit('update:b', 111)">修改父组件的a</button>
  ```
  ```js
  export default {
    props: {
      b: {
        type: Number,
      }
    },
  };
  ```

- 在组建上使用 v-model 指令，其实就是相当于将 props(:value) 和 自定义事件 (@input) 简化了. input 事件就是修改 value 的方法（v-model写在组件上，子组件想接收并修改props接收的值，实际上接收value就可以了，不能换成其它的属性）

    父组件内:定义number为一个值
    ```html
    <Son v-model="number"></Son>
    ```
    子组件内：这样就把父组件number的值修改了，变 200
    ```html
    <div>展示父组件内的 number: {{ value }}</div>
    <button @click="$emit('input', 200)">用v-model修改</button>
    ```

- provide 和 inject

    父组件内
    ```html
    <div>父组件的 provide: {{ x }}</div>
    <!-- 上面的语句会报错，因为父组件内拿不到自己provide里的值  -->
    <button @click="number = 20">修改provide里的number的值</button>
    ```
    ```js
    // 和data同级
    export default {
      provide: {
          x: 100,
      },
    }
    ```

    子组件内
    ```html
    <!-- 用inject来接收父组件provide的值并可以展示 -->
    <div>使用父组件 provide 的数据:{{ x }}</div>
    ```
    ```js
    export default {
      name: "Son1",
      inject: ["x"],
    };
    ```

    为了让父组件能拿到自己的值，我们一般写成函数，如下：
    父组件内
    ```html
    <div>父组件内的 number:{{ number }}</div>
    <!-- 在父组件中修改number的值，number变了，但是provide里的x值是不会变的 -->
    <!-- provide 提供的数据是不可响应的 -->
    <!-- 如果想提供相应数据，可以将数据做成响应的Vue.observable -->
    <button @click="number = 20">修改provide里的number的值</button>
    ```
    ```js
    export default {
      data() {
        return {
          number: 1000,
        };
      },
      provide() {
        return {
          x: this.number,
        };
    },
    ```
    子组件内
    ```html
    <div>使用父组件 provide 的数据:{{ x }}</div>
    ```
    ```js
    export default {
      inject: ["x"],
    };
    ```

    还有一种情况就是我们想在created里修改数据内容，但是子组件是不会接收到在里面修改的内容,如下:
    父组件：
    ```js
    data() {
      return {
        obj: {
          name: null,
        },
      };
    },
    created() {
      this.obj = { name: "小红" };
    },
    provide() {
      return {
        x: this.obj,
      };
    },
    ```
    子组件：
    ```js
    inject: ["x"],
    created() {
      console.log(this.x);
      // 拿到的值是null
    },
    ```
    解决以上问题，为了让子组件能拿到created里更新的数据：在父组件里定义一个方法，方法返回obj，在把方法赋给provide，如下：
    父组件：
    ```js
    created() {
      this.obj = { name: "小红" };
      // 这里是异步，子组件也能拿到
      // 在父组件里修改obj，子组件也会变，就是把数据变成可响应的了
    },
    provide() {
      return {
        x: this.getObj,
        // x: () => this.obj
        // 简化方法，然后可以把下面 methods 去掉
      };
    },
    methods: {
      getObj() {
        return this.obj;
      },
    },
    ```
    子组件：
    ```js
    inject: ["x"],
    // 子组件这样也可以对父组件的值进行修改
    created() {
      console.log(this.x());
      // 拿到小红
    },
    ```

- $attrs，$listeners

    app内：
    ```html
    <Parent2 :a="10" obj="小花" @x="() => console.log(1)" />
    <!-- 除了style和class的样式不能传之外，props里的所有属性都可传，直接在子组件里log(this.$attrs和$listeners)，就能拿到props和事件 -->
    ```
    Parent2内：
    ```html
    <Son2 v-bind="$attrs" v-on="$listeners" />
    <!-- v-bind 和 v-on 是给它的儿子组件传的，在它儿子里log，也能直接出现props和事件 -->
    ```

兄弟组件

- 将兄弟间需要相互使用的 data 共享到父组件内，那么兄弟之间的交互就变成了父子之前的交互了

## 自定义事件
- 父组件向子组件传递函数需要使用自定义事件，其实也可以直接使用 props,自定义事件名称推荐使用ebab-case 命名，不使用 camelCase 方式（驼峰）
父组件内
语法： @自定义事件名称="父组件内的函数名称"

```html
<!-- 第一种方式时直接将函数传递过去 -->
<Button @change1="change"></Button>
<!-- 第二种方式是将带参数的函数传递过去 -->
<Button @change1="change(index)"></Button>
```

子组件内
js 内

```js
  methods: {
    handleClick() {
      // 接收父组件传递过来的函数并调用
      this.$emit("change1");
      // 这是传参调用
      // this.$emit("change1",4);
    }
  }
```
- 当你要实现子组件同步父组件的 data 时，一般采取父组件内定义事件传递给子组件执 行的方案，此方案可以使用 .sync 修饰符简化
    自定义事件的基础写法，组件名写成 update:title
    父组件内的两种自写法
    ```html
    <!-- 还有一种就是将事件函数定义在父组件内的 methods 内 -->
    <!-- 下面的这个写法 $event 代表的就是子组件调用函数传递的参数 -->
    <Box :title="title" @update:title="title = $event"></Box>
    ```
    简化
    ```html
    <!-- 上面写法的语法糖 -->
    <Box :title.sync="title"></Box>
    ```
    子组件内
    ```js
    this.$emit("update:title", "新的值");
    ```
  tenplate 内

  ```html
  <button @click="handleSlide">
    {{ text }}
  </button>
  ```
  ```html
  <button @click="$emit('changeSearchValue',1)" />
  ```

自定义事件还有一个修饰符 .native ,该修饰符的作用就是将自定义事件直接绑定在子组件的根元素标签上，但是这类自定义事件名称必须和原生事件名称相同。

```html
<!-- 直接给子组件 Button 的根元素绑定了 click 事件 -->
<Button @click.native="change"></Button>
```
## 小提示
1. 子组件想要修改父组件的 data ？
    - data 只能在自己的组件内使用 this.dataName 修改，想要让其他人修改自己组件的 data ，那么需要先在自己组件内定义好修改的方法，然后将该方法传递给其他组件去执行
2. 为什么选择一个 data 不设置两个？
    - 因为只要定义了一个 data 那么 vue 就有针对这个 data 做一套虚拟 dom 流程
3. 如果图片的 src 地址写成了 js 相关的值，那么图片不会解析在浏览器上，解决方案：
    - 换成网络地址 推荐
    - 将 js 生成的图片地址使用 require(js地址) ,只能在 script 标签中使用
    ```html
    html
    <!-- 用变量的话这样用 -->
    <li :locate="require('../'+item.locate+'.jpg')"></li>
    
    js
    liArr:[{locate:"assets/p1"}]
    ```
4. 以后我们自己做项目的话可能会用到一些图片，这些图片写成本地的话不太好，将我们的图片上传到 github  或者 腾讯云 或者其他的免费网站
5. 报错 Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. 意思是：请避免直接修改 prop ，在父组件重新渲染的时候该属性会被重写（避免在子组件内修改父组件传过来的data）
6. 在 template 中当事件函数内想要使用事件对象请使用 $event
    ```html  
    <input type="text" @input="$emit('change-searchvalue',$event.target.value)" /> 
    <!-- 传的参数是dom节点的值 -->
    ```
7. 三目运算符的优先级低于 &&
8. if语句的简写方式，条件成立时，执行后面的语句，后面的语句必须和if在同一行
    ```js
    if(value) console.log(111),(console.log(222))
    else console.log(333)
    ```
9. 想按回车就添加，就v-on:keyup 或者可以keydown都可以，回车的编码是13，把enter 换成13也对
    ```html
    <input
    type="text"
    v-model.trim="value"
    @keyup.enter="handleClick"
    />
    ```
10. gitbash 不可用，使用 powershell 运行 vue ui 提示

    ```
    无法加载文件 C:\Users\sunnyzz\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https
    :/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
    ```

  以管理员身份打开命令行输入 `Set-ExecutionPolicy RemoteSigned` 然后输入 Y 。再次运行 vue ui 即可

11. 字体图标和自动生成代码（自定义代码片段）的视频是2020.8.31
12. 生命周期是同步的，发送请求是异步的
13. form 里的button 默认就是submit,想要需要写成如下：
    ```html
    <!-- event.preventDefault  阻止默认行为  a的超链接 表单的默认提交和重置  -->
    <button @click.prevent>确定</button>
    ```
14. 想要使用axios插件，需要在依赖下安装，在代码中引入
    ```js
    import axios from 'axios'
    ```
15. computed 该计算属性是在页面初始的时候就执行，所以在父组件的 computed 内无法获取子组件实例，也就是不可以使用 $refs 和 $children（因为子组件的created还渲染完，涉及到生命周期问题），computed里也不能做异步操作，不允许。

16. 事件修饰符 stop 阻止事件向上触发（在父级中写的click事件，在子级中也会触发，想要阻止就用stop）
    ```html
    <div @click.stop class="dialog">
    ```
17. get是请求(res是整个数组)，delete是删除(什么也不返回res是空的)，patch是修改(res返回修改之后的那条对象，而不是整个对象)，post是添加(res返回要新加的那一项),还有一个put（put和post都是修改，区别是put是更新，也就是更新所有项，而post是修改，可以只修改需要的某项）
    ```js
    axios.get("http://localhost:3000/books").then((res) => {
      console.log(res.data)
    // 整个数组
    });

    axios.delete("http://localhost:3000/books/" + id).then((res) => {
      console.log(res.data)
    // {} ， 输出空的。删除这条id和对象
    });

    axios.patch("http://localhost:3000/books/" + id, newBook).then((res) => {
      console.log(res.data)
      // 返回修改之后的那条对象也就是newBook，而不是整个对象
    });

    axios.post("http://localhost:3000/books", newBook).then((res) => {
      console.log(res.data)
      // 返回要新加的那一项，也就是newBook
      this.shuJi.push(res.data);
      // 想要显示在页面上，还需要添加上这一条对象，要不然是后台更新了，前端还没更新，不过一刷新就又有了
    });
    ```
18. 代码片段：按Fn+F1，输入snippets，选择首选项代码片段那个，然后选择vue.json, 默认有个log,的代码片段。地址[https://blog.csdn.net/maokelong95/article/details/54379046]
    ```js
      "Print to console": {
        "prefix": "log",
        "body": [
          // $1代表的是光标，${TM_FILENAME_BASE代表组件名
          "console.log('$1');",
          "$2"
        ],
        "description": "Log output to console"
      }
    ```
19. 当每个按钮对应每个点击事件时，没有必要写三个事件，可以写成一个 xx(属性名，属性值){this[名]=值}
    ```html
    <button @click="x(one,'one1')">按钮</button>
    <button @click="x(two,'two1')">按钮</button>
    ```
    ```js
    methods: {
      x(name, zhi) {
        this[name] = zhi;
      },
    },
    ```
20. Object.defineProperties  给对象添加一个或多个属性或方法，或者修改现有的属性
    ```js
    const obj = { a: 10, b: 30 }
    Object.defineProperties(obj, {
      b: {
        get() {
          return 20;
        }
      },
    });
    console.log(obj.b);
    ```
21. 运行依赖:项目必须(运行)依赖(axios vue-router element-ui ...) ,项目没有这个包不可能运行  --save  -S   
开发依赖:(sass less stylus ...) 工具类的(编译工具,插件类辅助工具)   --save-dev   -D
22. addEventListener和click的区别在于：两个click后面的会覆盖前面的，而两个addEventListener都触发,removeEventListener只能解绑addEventListener触发的事件
    ```js
    const fun = function(){
      console.log(11)
    }
    document.addEventListener("click", fun);
    document.removeEventListener("click", fun);
    ```
23. 22的补充:这种情况下就解绑不了，因为fun是一个函数，这个函数返回一个新函数，函数是一个对象，所以两次的地址不一样，返回的就不一样，就解绑不成功）
    ```js
    var fun = ()=> function(){
      console.log(11)
    }
    document.addEventListener("click", fun());
    document.removeEventListener("click", fun());
    // 不成功，想要解决用以下方案
    var fun = ()=> function(){
      console.log(11)
    }
    var a = fun()
    document.addEventListener("click", a);
    document.removeEventListener("click", a);
    ```
24. 模块内自带作用域，如果没有导出，别处是拿不到模块内的变量的
25. 组件内部想要调用自己必须先声明name属性，当作标签名，外面必须加判断
    ```html
    <!-- 这个例子会提示异常，因为调用太多了 -->
    <template>
      <div>
        <div v-if="num > 4">
          <Cascader />
        </div>
      </div>
    </template>
    <script>
    export default {
      name: "Cascader",
      data() {
        return {
          num: 5,
        };
      },
    };
    </script>
    <style></style>
    ```
26. Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

    属性 writable 是否能修改，默认为false
    ```js
    const obj = {
        name: '小黑'
    }
    Object.defineProperty(obj, 'age', {
        value: 10,
        writable:false
    })
    obj.age=11
    console.log(obj)
    // {name:'小黑',age：10}.因为writable是false,所以没有修改
    ```

    属性 get set（类似监听）
    ```js
    const o = {}
    Object.defineProperty(o, 'a', {
        value: 10
    })
    let bValue = 'hello'
    Object.defineProperty(o, 'b', {
      // 这里不能和vaue等其它属性一起用
        get() {
            return bValue
        },
        set(newValue) {
            bValue = newValue
        }
    })
    bValue = 100
    console.log(o);
    // {a:10,b:100},通过 get 接收，通过 set 修改
    ```

    玫举属性 enumerable
    ```js
    const o = {}
    Object.defineProperty(o, 'a', {
        value: 10,
        enumerable: true
    })
    Object.defineProperty(o, 'b', {
        value: 15,
        enumerable: false
    })
    Object.defineProperty(o, 'c', {
        value: 20,
        enumerable: true
    })
    // for..in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性
    for (var key in o) {
        console.log(key);
        // 结果 a c，因为b的玫举是false，所以这里不显示b
    }
    ```
27. 获取到当前页面锚点链接(#)
```js
const path= window.location.hash
console.log(path)
```

## 列表渲染

将一组数据循环渲染到页面上，需要使用指令 `v-for`
循环渲染两种情况

- 带数据的(有 data)
  <!-- item in arrList 就相当于遍历数组 arrList, item 代表每一项, -->
  ```html
  <!-- 想要使用下标的话  (item,index) in arrList -->
  <li v-for="(item,index) in arrList" :key="index">{{item}}</li>>
  ```
  ```html
   <!-- key 属性是必须的 而且该循环下唯一 -->
  <li v-for="item in arrList" :key="唯一值">{{item}}</li>
  ```
- 就是循环很多次，不需要 data。这种很少见
  <!-- 循环10次 -->
  ```html
  <li v-for="item in 10" :key="唯一值">{{item}}</li>
  ```
  
## 条件渲染

使用两个指令

- `v-show` 样式的消失和出现
  ```html
  <div v-show="listArr.length">
  <!-- 数组有值的情况下显示 -->
  ```
- `v-if` 可能搭配 `v-else` `v-else-if` 结构真正消失,需要注意 if else  elseif 使用的时候必须紧跟着中间不允许出现其他的元素，而且该指令对应的元素都是兄弟元素 
  ```html
  <span v-if="ind==0">1</span>
  <span v-else-if="ind==2">2</span>
  <span v-else-if="ind==3">3</span>
  <span v-else>4</span>
  ```
- 消失出现次数比较频繁使用 show, 消失出现次数比较少使用 if（show 只是显示隐藏，if就是有或没有，老师推荐使用v-show）

## style 和 class 绑定

style 行内样式 和 class 名在 vue 组件内的多种写法，其实就是为了更简单的去实现样式的修改。
style 绑定

- 默认的字符串方式
- 对象表示法
  ```html
  <!-- 古老的修改style的方法，因为fontSize中间有-，所以要加引号 -->
  <!-- <div class="box" :style="{'font-size': '50px'}">style</div> -->
  <div class="box" :style="styleObj">style</div>
  ```
  ```js
  data: function () {
    return {
      isHas: true,
      styleObj: {
        color: "red",
        fontSize: "50px",
      },
    };
  },
  ```
- 数组表示法((较麻烦不好用，老师没讲))

class 绑定

- 默认的字符串方式
  ```html
  <div class="box"></div>
  ```
- 对象表示法
  ```html
  <div :class="{box:true,active:true}">style</div>
  ```
- 数组表示法
  ```html
  <div :class="['box',isHas?'active':'']"></div>
  <div :class="['box','active']"></div>
  ```
- 数组内嵌套对象表示法
  ```html
  <div :class="['box',{active:true}]"></div>
  ```
## vue 的表单

vue 将表单的输入(文本)绑定成组件的 data ，用组件的 data 去控制。vue 提倡使用 v-model 指令去实现表单的绑定。我们也可以使用 value 配合 input 或者 change (.lazy) 事件替代 v-model 指令。

老方案：
```html
<input type="text" @input="handleChange" :value="username" /> 
```
```js
// data里，
username:"名字"
// 事件里，
handleChange(){
  // 先获取真实 dom 节点  event.target
  this.username = event.target.value;
}
```
新方案：
```html
<!-- change 对于 input：text | password 是属于失去焦点事件 -->
<!-- input 对于 input：text | password 是域的内容发生改变就会触发  -->
<!-- 使用 v-module 简化表单的双向绑定 -->
<input type="text" v-model="username" />
```
```js
data:function(){
  username:'名字'
  //此时username随便内容变化而变化，不用写事件
}
```
v-model 指令的修饰符

- .lazy 实现懒加载将 v-model 的默认事件从 input 改成 change
- .number 自动将输入的值使用 parseFloat() 转化成数字类型
- .trim 自动将输入的值的左右空白去掉
  ```html
  <input type="text" v-model.trim="password" />
  ```

## vue 组件的计算属性

你想对一个 data 进行复杂的逻辑操作后在放到页面上展示，此时我们可以直接将复杂的操作写在模版语法内，或者使用函数操作之后返回想要的值。但是 vue 组件提供了更好的方法 就是组件的计算属性(computed)，用法和 data 一致

```js
// 计算属性就是一个函数，该函数必须返回一个值，这个值就是计算属性，计算属性函数不可以传递参数
computed: {
    typeList() {
      return this.arr.reduce((res, item) => {
        if (!res.includes(item.category)) {
          res.push(item.category);
        }
        return res;
      }, []);
    }
  },
```
reduce是数组的遍历，箭头函数可以不写return，而对于返回对象来说的说，可以去掉return，把{}换成(),res是最终的结果，item是遍历的每一项， { totalPrice: 0, totalNum: 0 }是res的初始值，函数里要返回新的结果来继续遍历，遍历之后res为最终的结果。
```js
computed: {
  total() {
    return this.products.reduce(
      (res, item) => {
        return {
          totalPrice: res.totalPrice + item.price * item.quantity,
          totalNum: res.totalNum + item.quantity,
        };
      },
      { totalPrice: 0, totalNum: 0 }
    );
  },
  // total() {
  //   return this.products.reduce(
  //     (res, item) => ({
  //         totalPrice: res.totalPrice + item.price * item.quantity,
  //         totalNum: res.totalNum + item.quantity,
  //     }),
  //     { totalPrice: 0, totalNum: 0 }
  //   );
  // },
},
```

```js
// 一会研究一下！
const newArr = new Set(arr.map(item => item.category));
```


当你的一个计算属性想要实现反向操作的时候，意思就是直接给计算属性重新赋值，然后让计算属性的来源 data 被修改。此时可以给计算属性设置 setter ,代码如下

```js
// firstName 和 lastName 是组件的 data
// 当计算属性存在 setter 的时候计算属性就写成了 对象类型
computed: {
    fullName: {
      get() {
        return this.firstName + " " + this.lastName;
      },
      set(newValue) {
        // newValue 代表新的计算属性 或者叫更改之后的计算属性
        // setter 用来修改计算属性的来源 data 的
        this.firstName = newValue.split(" ")[0];
        this.lastName = newValue.split(" ")[1];
      }
    }
  },
```

## vue 组件的侦听器 watch

当你的计算属性需要根据异步操作来计算，但是计算属性函数内要直接返回结果，不能添加异步操作。所以可以使用 watch 实现。
使用案例

```js
// question 和 answer 是组件的 data，answer 要随着 question 的变化而变化，但是如何变化要发送请求才知道
// watch 对象下有几个属性
// 第一个 handler 是数据变化的触发的函数
// 第二个 immediate 在组件初始化的时候就执行一次 handler
// 第三个 deep 为了发现对象内部值的变化，可以在选项参数中指定 deep: true。
watch: {
    question: {
      // 监听 question 修改 answer
      handler() {
        // 当 question 发生变化是就会执行
        if (this.question) {
          setTimeout(() => {
            // 向后台获取答案
            this.answer = Math.random();
          }, 100);
        }
      },
      // 进入页面就执行一次
      immediate: true
    }
  }
```

## vue 组件的 ref

当你想在 vue 组件内获取一个元素的真实 dom 结构的时候，可以使用原生方案 document 一套，也可以借助插件(没讲)。但是呢，vue 其实提供了一个方案，就是组件的 ref。一般获取真实 dom 节点用于获取某个值，并不是用于修改。

```html
<button ref="btnDom"></button>
```

```js
this.$refs.btnDom;
// 就是获取了 button 的原生 dom
```

其实 ref 也可以直接写在组件上,那么获取的就是该组件实例，也就是说可以获取组件内的所有内容。进而也就可以实现父子组件之间的交互。
```html
<li ref="ceShi"/>
<!-- li是组件 -->
```
```js
console.log(this.$refs.ceShi.arr)
//this.$refs.ceShi 相当于该组件里面的this.arr
// 也可以调用子组件的方法
this.$refs.ceShi.方法名()
```

## 组件内的 this

组件内使用 this 其实就是想要使用该组件下的 data props methods computed 自定义事件 ref ... ,那么组件内我们通常使用的 this 就指的是该组件的实例(VueComponent)。
如何获取组件实例

- methods 将函数设置成普通函数，该函数的根作用域下的 this 就是组件实例.如果根作用域内的其他子作用域想要直接访问 this 那么请设置成箭头函数（箭头函数下的this 就是vue组件，而普通函数下的this就是调用的window，比如，settimeout）
- computed 跟上面 methods 一样
- 生命周期函数跟上面一样

## 组件的生命周期

组件从出现到渲染页面或者再页面中销毁，各个阶段 vue 都提供了对应的函数，供开发者使用。这些函数被称作生命周期钩子。生命周期钩子是同步函数。

初始渲染阶段

- beforeCreate
- created: data 等其他组件的数据处理完毕,可以在页面初始的时候发送请求更新数据。发送请求使用的是 axios 插件。
- beforeMount
- mounted: 组件在页面渲染完毕，可以获取组件内的真实 dom 节点。

数据更新阶段

- beforeUpdate 数据更新时调用，发生虚拟 dom 打补丁之前
- updated 数据更新完毕，dom 渲染完毕

组件的销毁阶段

- beforeDestory 组件即将被销毁，并不是组件的内容在页面上消失
- destoryed 组件销毁完毕，v-if属于销毁，v-show不属于，需要写在组件内，销毁的是组件。 我们在这个生命周期内，可以手动解除一些跟该组件的无关的一些操作(setInterval 跟浏览系相关的一些事情，setInterval属于浏览器，所以即便组件销毁了，setInterval也不会停止)

  ```js
  // 生命周期
  // 阶段 一
  // 初始渲染阶段 (其实就是页面刚进入的时候或者刷新的时候)
  // 该阶段需要实现的大概有 获取页面初始数据(进入页面就向后台获取数据然后更新页面，或者其他的一些进入页面就需要做的事)
  beforeCreate() {
    console.log("组件刚被创建，在初始化data之前");
  },
  created() {
    console.log(
      "组件的数据观测 (data observer)，property 和方法的运算，watch/event 事件回调,配置完毕"
    );
    // 此阶段最适合进入页面就修改 data ，发送请求获取后台数据，修改 data
    axios.get("http://localhost:3000/articles").then(res => {
      // console.log(res.data);
      setTimeout(() => {
        this.articles = res.data;
      }, 1000);
    });
  },
  beforeMount() {
    console.log("组件即将要渲染，挂载之前");
  },
  mounted() {
    console.log("渲染执行完毕");
    // console.log(document.querySelector(".title"));
    // 刚进入页面想要获取真实的 dom 节点做一些功能，在此阶段可以实现,但它在异步之前就执行完毕了
    // 比如说 swiper 插件  使用的时候  new Swiper('.container')  需要获取真实 dom 节点 container
  }
  ```

## axios 封闭
  ```js
  app.vue
  // 其中地址可以写成空，因为可以设置默认地址，有时也可以删除，切记一一对应
  $http("delete", id) //id对面自动连接上
  $http("post", "http://localhost:3000/books", newBook
  $http("get", "http://localhost:3000/books")
  $http("patch", newBook.id, newBook)
  //可以传过去对象，对面接收语法是config，
  $http({ method: "delete", url: id });
  $http({ method: "post", data: newBook })
  $http({ method: "get" })
  $http({ method: "patch", url: newBook.id, data: newBook })

  //可以传三个参数过去

  ```

  ```js
  axios.js
  // 先是导入js，两种方式
  import $http from "./axios"; // 默认导入
  import { $http } from "./axios"; // 命名导入

  // 封装 axios 请求
  // 将请求整合到一处便于管理
  // 默认导出
  import axios from "axios"
  // axios 请求就会返回一个 promise
  // 当你的请求都是基于一个服务器下的时候，可以给请求设置基地址
  // 配置 axios 请求的默认基地址
  axios.defaults.baseURL = "http://localhost:3000/books"
  // export default (type, url, params) => {
  //     return axios[type](url, params)
  // }
  export default config => {
      return axios(config)
  }
  // 将函数的参数设置成对象的话比较好
  // 因为将对象拆分成三个参数的话必须传递三个参数才能一一对应.
  // 对象是有属性名的，属性名对应即可

  //命名导出
  const $http = (type, url, params) => {
      return axios[type](url, params)
  }
  export { $http }
  ```

## 动态组件

当你想要根据一个数据切换不同组件的展示，此时可以使用动态组件。动态组件是由 vue 的自带 component 元素搭配 is 属性代码如下
动态组件的切换方式是属于 v-if 的切换

```html
<!-- currentComponentName属性 的值需要和组件名相同 -->
<!-- 当修改 currentComponentName属性 的时候就会切换不同的组件展示了  -->

<!-- <Home v-show="activeType==='Home'" />
<Posts v-show="activeType==='Posts'" />
<About v-show="activeType==='About'" /> -->
<component :is="currentComponentName"> </component>
```

动态组件搭配 keep-alive 实现动态组件的数据缓存。允许组件有条件的缓存（include,exclude,max）
当动态组件切换的时候每个组件默认都会变成初始状态，假如有的组件内有 data 并且希望 data 修改的时候能够保留，意思就是动态组件切换的时候中间的某个组件的 data 不会被初始化。此时就需要使用 keep-alive

```html
<keep-alive include="Home" exclude="Home" :max="10">
  <!-- includes 属性的属性值可以是字符串或者正则，匹配的组件名才缓存数据 -->
  <!-- exclude 与 includes 相反 -->
  <!-- max 最多缓存的组件实例个数   -->
  <component :is="currentComponentName"> </component>
</keep-alive>

```
还有一种更新title的方法：
```html
父组件
<!-- <component :title="title" @handle-title="handleTitle" :is="activeType"></component> -->
<!-- $event类似于传过来的值， -->
<!-- <component :title="title" @update:title="title=$event" :is="activeType"></component> -->
<!-- 上种方式可以简写成如下： -->
<component :title.sync="title" :is="activeType"></component>
子组件
<!-- <button @click="$emit('handle-title','three')">three</button> -->
<!-- 子组件的update:title,在父组件直接简写成了.sync就行 -->
<button @click="$emit('update:title','three')">three</button>
```

## vue 自带的动画和过渡效果

vue 本身自带了一个 transition 组件，使用该组件配合一些样式就可以实现进入 or 离开的过渡或者动画效果

- v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。

- v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

- v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。

- v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。

- v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

- v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。

1. 用transition把 动画/过渡 包起来
    ```html
    <transition appear name="fade">
      <p class="tran-text" v-if="show">Hello</p>
    </transition>
    ```
2. transition里写上 name 面，替代上面的 v
    ```js
    .bounce-leave-active {
      // bounce只的是name名，reverse 是相反的执行
      animation: bounce-in 0.6s reverse;
    }
    @keyframes bounce-in {
      0% {
        transform: scale(0);
      }
      50% {
        transform: scale(1.5);
      }
      100% {
        transform: scale(1);
      }
    }
    ```
3. appear是一上来就执行一次 动画/过渡,也可以设置自定义动画，其中appear不能省略,没有appear-to-class默认和初始效果一样
    ```html
    <transition
      appear
      name="fade"
      appear-class="rotate-enter"
      appear-active-class="rotate-active"
      appear-to-class="rotate-to"
    >
    ```
    ```js
    .rotate-enter {
      transform: rotate(360deg);
    }
    .rotate-active {
      transition: all 1s;
    }
    .rotate-to {
      transform: rotate(180deg);
    }
    ```
**多个元素过渡**

当有相同标签名的元素切换时，需要通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。

- in-out：新元素先进行过渡，完成之后当前元素过渡离开。
- out-in：当前元素先进行过渡，完成之后新元素过渡进入。

  ```html
  <!-- 当你点击按钮的时候实现的动画效果按钮先渐渐消失然后在渐渐出现  -->
  <!-- 按照之前的过渡效果去设置的话，两个元素会同时执行动画，如果希望一个元素效执行效果，然后另外一个在执行的话需要给 transition 加上 mode 属性 -->
  <transition name="fade1" mode="out-in">
    <button v-if="!state" @click="state=true" key="on">on</button>
    <button v-else @click="state=false" key="off">off</button>
  </transition>
  ```

上述方法可以重写成如下:
  ```html
  <transition name="fade1" mode="out-in">
      <button @click="state=!state" :key="state">{{state?'off':'on'}}</button>
  </transition>  
  ```

列表渲染

需要使用 transition-group 组件,会渲染成一个标签，默认是span
有一个插件和axios类似，'loadsh'，其中有一个方法shuffle,

```js
import _ from "loadsh";
// 一个单击事件，把listNum数组倒换顺序。
 methods: {
    shuffle() {
      this.listNum = _.shuffle(this.listNum);
    }
  }
```

```html
<transition-group name="list" tag="ul">
  <!-- <ul> -->
  <li v-for="num in listNumber" :key="num">{{num}}</li>
  <!-- </ul> -->
</transition-group>
```

## vue 的路由 vue-router

对于 vue 这种单页面应用，官方提供了 vue-router 库，来实现多页的效果。
如何实现

- 安装 vue-router 包   插件，依赖
- 新建页面，一般是在views文件夹下，比如 Home.vue,About.vue
- 新建 router.js 里面创建路由(src下)
  ```js
  // 一 。创建页面路由
  // 1. 导入页面组件
  import VueRouter from "vue-router";
  import Vue from "vue";
  import Home from "./views/Home.vue";
  import About from "./views/About.vue";
  Vue.use(VueRouter);

  // 2. 根据页面组件创建路由数组
  const routes = [
    // 该数组内的某一项就相当于一个页面，页面一般有两部分构成 1. 页面地址  2.页面对应的页面组件
    // / 的意思代表当前服务器的根目录 我们现在其实就是 http://localhost:8000
    // http://localhost:8000/#/
    // http://localhost:8000/#/about
    { path: "/", component: Home },
    { path: "/about", component: About },
  ];

  // 3. 根据路由数组创建出路由实例
  const router = new VueRouter({
    routes,
    // 可以选择性的创建路由模式
    // 分为两种 1. hash(默认的 /#/ )    2. history(需要设置，没有/#/ )
    mode: "history"
  });

  // 4. 创建完毕之后,导出路由实例,添加到整个 vue 项目中. 参考 main.js 的写法
  export default router;

  // 5. 在main.js中导入 
  import router from "./router";
  new Vue({
    router,
    render: h => h(App)
  }).$mount("#app");
  
  ```
  ```html
  <!-- 6. 使用 -->
  <ul>
     <!-- 该组件展示的就是路由(页面) 路由的匹配规则要根据当前页面地址和路由的 path 进行匹配 匹配规则是完全匹配-->
    <!-- router-view 代表路由(页面)内容，使用 router-link(a) 组件进行路由(页面)跳转 -->
    <li><router-link to="/">home</router-link></li>
    <li><router-link to="/about">about</router-link></li>
  </ul>
  <router-view></router-view>
  ```


快速创建路由方式(前提是 vue 的环境时 vue-cli3.0 以上)

- 使用 vue ui 安装插件，选择安装 vue-router 的插件
- 使用命令行工具 执行 `vue add vue-router`

快速安装之后，项目内就会自带一个路由 demo，直接使用即可

对于 router-view 和 router-link 组件的各种配置参考 [vue-router 官方文档](https://router.vuejs.org/zh/)

### router-link 有个属性 active-class
此link激活时的类名，根据地址匹配，默认是包含匹配，想要精确匹配需要 exact 默认是true
,也有默认的类名：router-link-active
```html
<!-- 详情见上面链接中的api文档 -->
<li>
  <router-link active-class="cc" exact to="/">home</router-link>
</li>
<li>
  <router-link active-class="cc" exact to="/about">about</router-link>
</li>

<style>
  .cc{
    color:blue;
  }
</style>
```
 
## vue-router 进阶

### 导航守卫
路由跳转的时候会默认触发的一些函数，帮助开发者更好的实现路由的跳转。
一般写在main.js

详细流程请看文档
<!-- 流程：2 1 4 5， -->
- 全局前置守卫1
  ```js
  router.beforeEach((to, from, next) => {
    // to 和 from  获取的就是组件内的 $route
    console.log("全局前置守卫");
    next();
    if (to.path === "/" || login) next();
    else alert("未登录，请先登录"), next("/");
    // next 参数是一个函数 该函数的作用就是 通行
  });
  ```
- 全局解析守卫2
  ```js
  // 和全局前置守卫差不多，多数用上面的。
  router.beforeResolve((to, from, next) => {
    console.log("全局解析守卫");
    next();
  });
  ```
- 全局后置钩子3
  ```js
  router.afterEach((to, from) => {
    // 没有next函数
    console.log("全局后置钩子");
  });
  ```
- 路由独享守卫4
  ```js
  // 单个用在路由中,不如组件内的守卫好用
  {
    path: '/',
    name: 'Home',
    component: Home,
    beforeEnter: (to, from, next) => {
      console.log(to);
      console.log(from);
      console.log("home路由独享守卫");
      next()
    }
  },
  ```
- 组件内的守卫   
  ```js
  export default {
    name: "About",
    // 进入流程 1 6 2 3 
    // 离开流程 8 1 2 3
    beforeRouteEnter(to, from, next) {
      // 6
      console.log("组件内的路由跳转之前的守卫");
      next();
      // 不！能！获取组件实例 `this`
      // 因为当守卫执行前，组件实例还没被创建
    },
    beforeRouteUpdate(to, from, next) {
      // 7
      console.log("组件内的路由改变但是还是展示的该组件");
      next();
      // 可以访问组件实例 `this`
    },
    beforeRouteLeave(to, from, next) {
      // 8
      console.log("组件内的离开当前路由的守卫");
      next();
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
    },
  };
  ```

### 过渡动效
其实就是使用 vue 自带的 transition 组件实现过渡效果

###　数据获取(异步)

- 组件的生命周期内获取
- 组件的路由守卫内获取

一般在组件内获取数据
```js
// 在 beforeRouteLeave beforeRouteUpdate就不能拿到vm
 beforeRouteEnter(to, from, next) {
    console.log("组件内的路由跳转之前的守卫");
    setTimeout(() => {
      const newNum = to.query.sort === "hot" ? 1 : 100;
      next((vm) => {
        // vm 指得是组件实例
        console.log(vm);
        vm.setNum(newNum);
        // vm.num = newNum; 还是按照官方提供的写，以上。
      });
    }, 1000);
  },
  methods: {
    setNum(newNum) {
      this.num = newNum;
    },
  },
```

### 滚动行为
就是在创建路由实例的时候添加一个 scrollBehavior 方法。
默认的滚动行为是回到之前的位置

  ```js
  const router = new VueRouter({
    routes,
    mode: "history",
    scrollBehavior(to, from, savedPosition) {
      // 当按下浏览器的前进后退按钮 savePoition 就存在，或者使用 路由的 back  go 等方法也可以
      if (savedPosition) {
        return savedPosition;
      } else {
        // 没按下前进后退直接滚动到顶部
        return { x: 0, y: 0 };
      }
    }
  });
  ```
  ```js
  methods: {
    back() {
      this.$router.back()
    }
  }
  ```
##  vue 的常用 ui 库，element-ui

普通的



安装方式

- 安装 `npm i element`
- 使用
  - 完全引入(不推荐)，直接将 element-ui 和他的 css 导入到 main.js，并且使用 Vue.use 方法将 element-ui 的所有组件，创建成项目全局的组件
  - 按需引入
    - 安装 babel-plugin-component 插件，辅助按需引入
    - 在项目根目录下的 .babel.config.js 添加一项 plugins 配置
    - 在 main.js 中导入所需要的组件，并使用 Vue.use 方法组件创建成项目全局的组件

## Message 插件有两种导入方法
全局导入 
```js
// 在main.js中全局导入 
import { Message } from 'element-ui';
// 将 Message 方法 添加到整个 vue 的原型对象内，也就是整个项目内都可以使用  this.$message 访问
Vue.prototype.$message = Message

// 在App内用this使用
open2() {
  this.$message({
    message: "恭喜你，这是一条成功消息",
    type: "success",
  });
},
```
单独导入 
```js
// 在App内单独导入 ，Message 指得是一个函数
import { Message } from "element-ui";

open2() {
  Message({
    message: "恭喜你，这是一条成功消息",
    type: "success",
  });
},
```
## InfiniteScroll 无限滚动

滚动至底部时，加载更多数据。使用时如果是按需引用，需要导入 InfiniteScroll(复制粘贴·)
```js
import {InfiniteScroll } from 'element-ui'
Vue.use(InfiniteScroll)
```

```html
<ul
  class="infinite-list list"
  v-infinite-scroll="load"
  style="overflow: auto"
  :infinite-scroll-disabled="count >= 50"
>
  <li v-for="i in count" class="infinite-list-item" :key="i">{{ i }}</li>
</ul>
```
## cube-ui
1. 用插件安装:plugin-cube-ui(按需引用,安装后之后把所有的需要都自动引入进来了)
2. 命令:vue add cube-ui(自己去看文档吧,实在整不出来笔记!)
(主要 vue ui 库:pc  element-ui  iview  antd ...
  移动端 cube-ui  mint-ui  ...)

## vue的style样式 : scss less stylus
- 当使用了第三方插件库的时候 scoped 属性只会将 插件的组件的最外层标签加上 scoped 设置的属性，那么里面的标签想要使用类名修改样式就不行了,去掉scoped就可以了

### scss
```js
/* scss 语法就 css 的扩展语法 */
/* 默认我们先安装的 vue 环境是不支持 scss 语法的需要安装工具 */
/* 需要安装 node-sass 以及 sass-loader 到开发依赖 */
/* 安装好了工具包之后就可以字啊组件内使用 scss 语法了 这是里$*/ 

// 1. 样式嵌套
// 2. 设置变量
// 3. 运算
// 4. if 或者 for
// 5. 样式的导入
<style lang="scss">

@import '../assets/public.scss';
$active: red;
.scss-demo {
  h3 {
    color: $active;
    width: $width;
    // $width 是在public.css里(样式的导入)
  &:hover h3 {
    color: #000;
    // &代表的是父级
  }
}
```
### less
```js
//  需要安装 less-loader 和 less 基础用法和 scss 一样,这里用@,less和scss基本上一样
<style lang="less">
@color: red;
.less-demo {
  h3 {
    // color: teal;
    color: @color;
  }
}
</style>
```
### stylus
```js
// 需要安装 stylus stylus-loader  注意 stylus-loader 最近更新了 4 版本但是 vuecli4 能使用 3 版本，所以安装 stylus 的 3 版本才可以
// vscode 安装了 vetur 那么 vue 组件内的 style 写 stylus 样式的时候会自动补齐，不想自动补齐 文件--->  首选项---> 设置--->  搜stylus 关闭格式化
</script>

<style lang='stylus' scoped>
h3 
  color teal
  font-size 20px
</style>
```
## flex 布局方式 (去看文档吧!)
1. flex 是一种弹性盒子布局方式
2. 抛弃原来的 float 布局方式,float、clear和vertical-align 禁止使用
3. flex 核心
  - 容器:   设置了 display:flex; 的元素就是容器
  - 容器的属性:  flex-direction    flex-wrap    flex-flow   justify-content  align-items  align-content
  - 容器的轴线: 分横向和纵向，默认主轴线是横轴 
  - 项目:   display:flex; 的子元素就是项目,项目在主轴线并不会超出盒子，而且项目按照容器的主轴线排列，项目会自动转化为块元素,项目如果没有设置副轴高度默认和容器的高度一致(如果按列排，高就不会超出盒子;如果按行排，宽就不会超出盒子)
  - 项目的属性:  order  flex-grow  flex-shrink  flex-basia flex  align-self

## vue使用swiper
1. 运行依赖里安装,swiper
2. 引js,和css,直接在需要用swiper的组件里引就行
```js
// 直接安装 6 版本的swiper会出问题建议安装 5 版本
import Swiper from 'swiper'
// 当你想要引入 包 内的其他文件，路径直接写第三方包名 + / 找即可
import 'swiper/css/swiper.min.css'
```
3. 进入页面的时候只有在该生命周期才能获取真实 dom 节点才可以执行一些相关操作,所以js的内容写在mounted里

## echarts
1. 安装运行依赖,echarts
2. 引入一些需要的模块
```js
// 引入 ECharts 主模块,因为下面需要用echarts对象所以命名了,引入的都是功能,不需要命名,引入了就行了
import echarts from 'echarts/lib/echarts'
// 引入柱状图
import 'echarts/lib/chart/bar'
// 引入提示框和标题组件
import 'echarts/lib/component/tooltip'
import 'echarts/lib/component/title'
// 引入提示的方框
import 'echarts/lib/component/legend'

// 详情见vue-native-demo
```
## vuex

## Vuex 状态管理模式
就是实现组件之间交互的终极方案。将组件间需要交互的数据(data),共享到 vuex 创建的 store(仓库) 内。

### store 的创建

- 安装 vuex `npm i vuex`
- 或者在运行依赖里安装 vuex
- 在 src 下新建 store.js 文件用来创建 store
  store.js
  ```js
    // 一. 导入 vuex 和 vue 使用 Vue 的 use 方法将  vuex 做成全局
    import Vue from 'vue'
    import Vuex from 'vuex'
    Vue.use(Vuex)

    // 二. 创建 store 仓库，需要使用 Vuex.Store 类(class)  创建
    const store = new Vuex.Store({
      // 相当于定义变量
      state: {
        num: 100
      },
      // 相当于变量的方法
      mutations: {
          update(state) {
              state.num++
          }
      }
    })
    // 三. 将创建好的 store 导出
    export default store
  ```
- 在 main.js 内导入 store , 将 store 加入到整个 vue 的项目实例内
  ```js
  // 四. 在 main 内导入，并且在创建整个 vue 项目的实例的时候添加上 store
  import store from "./store"

  new Vue({
    render: h => h(App),
    // store:store
    store
  }).$mount('#app')

   // 上述四步完毕之后，vue 项目的所有组件内都可以使用了
  ```

注意：
```js
 methods: {
    update() {
      this.$store.state.num++;
    },
  },
// 上述操作可以修改 store 内的数据,但是绝对不能使用，就和我们之前说的当 props 是对象的时候子组件不要直接修改，这样修改了之后追踪不到修改的来源
// 想要修改 store 内的数据，必须使用 commit 来触发 mutation 函数，代码如下：
methods: {
    update() {
      // this.$store.commit("update");
      // 也可以写成如下，但前提得引入store.js, import store from "../store";
      store.commit("update");
    },
  },

```
```js
// payload 为载荷数据

// 组件内：
methods: {
  change() {
    this.$store.commit("change", {
      num1: 10,
      num2: 20,
    });
  },
},
// store.js内
mutations: {
  change(state, payload) {
      state.num = payload.num1 + payload.num2
  }
}
```
```js
// commit 提交 mutation 可以直接使用 对象形式提交,那么 mutation 函数的第二个参数就会接受整个对象

// 组件内：
change() {
  this.$store.commit({
    // type 代表 mutation 方法名
    type: "change",
    new:{
      num1: 10,
      num2: 20,
    }
    
  });
},
// store.js内：
mutations: {
  change(state, payload) {
    console.log(payload)
    // 拿到的是整个对象
    state.num = payload.new.num1 + payload.new.num2
  }
}
```

### store 的使用

- 组件内获取 store 数据
  ```js
    // 一般获取 store 内的数据写成计算属性的方式
    computed:{
      count: this.$store.state.count
    }
    // vuex 提供了 mapState 辅助函数
    // 就是将 store 内的数据使用该函数映射成组件的 computed
    computed: {
      ...mapState(['count']),
      ...mapState({
        myCont: 'count'
      }),
      ...mapState({
        myCont: state => state.count,
        myCount(state){
          // 这个函数内可以使用 this
          return state.count
        }
      })
    }
  ```
- 组件内修改 store 数据
  - 需要在创建 store 的时候定义好修改的方法,也就是创建 mutation 
    ```js
      const store = new Vuex.Store({
        ...
        mutations: {
          add(state){
            state.count++
          }
        }
      })
    ```
  - 在组件内使用 `store.commit('add')` 来修改 store 中的数据


### mutations 

mutation 是函数，这个函数用来修改 store 内的数据的。想要调用这个 mutation 函数的话，必须使用 store 内的 commit 方法。
创建
  ```js
    const store = new Vuex.Store({
      state: {
        num: 0
        ...
      },
      mutations: {
        // mutation 函数只能接收两个参数
        // mutation 函数默认第一个参数是 state,函数内部直接对 state 内的数据进行修改
        // mutation 函数第二个参数是 payload,修改 state 需要的额外内容,一般写成对象类型
        // mutation 函数必须是同步函数，里面不能加异步操作
        add(state){
          state.num ++
        },
        change(state,payload){
          state.num = payload.newNum
        }
      }
    })
  ```
组件内使用
  ```js
    // 1. 使用 this.$store.commit 去提交 mutation
    this.$store.commit('add')
    this.$store.commit({
      type: 'add'
    })
    this.$store.commit('change',{newNum: 100})
    this.$store.commit({
      type: 'change',
      newNum: 100
    })
    // 2. vuex 提供了 mapMutations 辅助函数
    // 就是将 store 内的 mutation 函数，映射成组件内的 method，并且内部自带 commit 功能

    import  {mapMutations } from 'vuex'

    export default {
      // ...
      methods:{
        // 1. 单击事件里的名字和mutation里的名字相同
        @click="CHANGE({ numData: 500 })"
        ...mapMutations(['ADD','CHANGE']),
        // 2. 单击事件里的名字和mutation里的名字不同
        @click="update({ numData: 500 })"
        ...mapMutations({
          jia: 'add',
          update: 'change'
        })
      },
      // 如果 methods 内没有其他的方法可以写成下面的方式
      methods: mapMutations({
          jia: 'add',
          update: 'change'
        })
    }  

    // 3. vuex 提供了 mapState 辅助函数，和mapMutations差不多
    // mapState 辅助函数帮助我们生成计算属性
    computed: {
      // num() {
      //   return this.$store.state.num;
      // },
      // arr() {
      //   return this.$store.state.arr;
      // },
      // 1. 数组用法：
      // ...mapState(["num", "arr"]),
      // 2.对象用法第一种
      // ...mapState({
      //   number: "num",
      //   array: "arr",
      // }),
      // 3. 对象用法第二种
      // 箭头函数获取不到this，所以用普通函数
      // ...mapState({
      //   number: (state) => {state.num},
      //   array: (state) => state.arr,
      // }),
      ...mapState({
        number(state) {
          return state.num + this.a;
        },
        array: "arr",
      }),
    },
  ```
### getters

就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

  ```js
  getters: {
      // getters 内的函数的第一个参数默认接收 state 作为参数
      // getters 内的函数的第二个参数是 store 的所有 getters 
      // 下面的 sum 是求和计算属性
      sum(state,getters){
        return state.arr.reduce((res,ele)=> res +=ele,0)
      },
      // 下面的 getNum 是获取对应的某个 num , 跟给定的值最接近的那个数
      // 做此功能需要组件内传递限定值
      // 但是默认 getters 的函数是不能接收组件内传递参数的，想要传递话，需要将 getters 函数写成 返回一个函数的函数 ,再返回的函数内接收参数，而且返回的函数的返回值是最终的计算属性
      getNum(state){
        // 20    [11,22,30]      绝对值  Math.abs(x)
        return (limitNum)=> {
          const arr = state.arr
          let res = arr[0]
          if(!(res - limitNum === 0)){
            for (let i = 1; i < arr.length; i++) {
              if(Math.abs(arr[i]- limitNum) < Math.abs(res - limitNum) ){
                res = arr[i]
                if(arr[i] - limitNum === 0){
                  break
                }
              }
            }
          }
          return res
        }
      }
    }
  ```
  ```js
    // 触发getters
    limitNum() {
      return this.$store.getters.getNum(30)
    },
    ...mapGetters(["sum", "getNum"]),
    // <div> {{ getNum(30) }}</div>
    ...mapGetters({
      res: 'sum',
      limitNum: 'getNum'
    })
  ```
  ### actions

  Action 类似于 mutation，不同在于:Action 提交的是 mutation，而不是直接变更状态;  Action 可以包含任意异步操作。

  ```js
    // 只要有 action 函数就会有对应的 mutation 函数，所以名称一般写成重名的
    // action 函数默认接受一个 context 作为参数 context 是一个对象，对象下有 commit 方法 以及 store 内的 state
    // 当没有异步操作的时候也可以设置 action 函数
   mutations:{
    updateArr(state,payload){
      console.log('要修改 arr');
      //mutation 函数只能是同步函数不能包含异步操作,需要actions
      // setTimeout(() => {
      //   state.getArr = [1,2,3]
      // }, 1000);
      state.arr = payload.res
    },
  }
  actions:{
    updateArr({commit},payload){
      console.log(payload.id);
      setTimeout(() => {
        // 用commit触发mutations
        commit({type: 'updateArr',res: [11,22,30]})
      }, 2000);
    }
  },
  ```
  ```js
  created(){
    this.$store.dispatch('updateArr')
    // 触发 action 也可以写成
    this.$store.dispatch({
      type: 'updateArr',
      // 随便测试了个参数  id
      id: 1
    })
  },
  methods: {
    // 只能映射成 methods 才带 commit 功能
    // 其他地方想要使用 使用 this 获取
    ...mapMutations(['updateArr'])
  }
  
  ```


### 使用常量替代 Mutation 事件类型（随意用不用）
```js
  // 把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：

  // 1. 先建一个 mutation-types.js，里面导你出的方法
  // mutation-types.js内
  // export const ADD = 'ADD'
  // export const CHANGE = 'CHANGE'
  const ADD = 'ADD'
  const CHANGE = 'CHANGE'
  export { ADD }
  export { CHANGE }

  // 2. 在store.js里导入
  // store.js
  import { ADD, CHANGE } from "./mutation-type"

  mutations: {
    // 因为ADD是字符串，使字符串变成函数名或变量加上中括号
      [ADD](state) {
          state.num++
      },
      [CHANGE](state, payload) {
          state.num = payload.new.num1 + payload.new.num2
      }
  }

  // 3. 在组件中也要导入
  // 组件中：
  import { ADD, CHANGE } from "../mutation-type";

  methods: {
    update() {
      store.commit(ADD);
    },
    change() {
      this.$store.commit({
        type: CHANGE,
        newNum: 1000,
      });
    },
  },
```

### vuex 插件

 Vuex 自带一个日志插件用于一般的调试，就是当 store 数据发生改变的时候，自动在浏览器中打印详情

```js
// 先导入插件，然后在下面使用
import createLogger from 'vuex/dist/logger'

const store = new Vuex.Store({
  ...
  plugins: [createLogger()]
  ...
})
```
### 严格模式
```js
export default new Vuex.Store({
  // 当触发开发环境下执行 vuex 的严格模式
  // 严格模式下的state数据必须通过mutation去修改
  strict: process.env.NODE_ENV !== 'production',
})
```
### 表单处理
当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手,可以使用以下方式解决此类问题。

```js
  <input type="text" v-model="objName" />

  computed: {
    // 为什么计算属性不写成 obj 而是写成 objName
    // 因为直接写成 obj 的话，当输入框的值修改的时候，修改的是 obj.name ，obj地址 并不会发生改变，那么 set 函数并不会触发
    objName: {
      get() {
        // get内获取到值
        return this.$store.state.obj.name
      },
      set(newValue) {
        // set 内修改值，修改 store 内 obj，需要调用 mutation
        this.$store.commit('changeObjName', newValue)
      }
    }
  }
}
```
```js
 mutations: {
    changeObjName(state,newName){
      state.obj.name = newName
    }
  },
```

### module命名空间
如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。只有 action 是注册在全局命名空间的。

```js
// 1.  新建一个模块 a    (a.js),
const a = {
  namespaced: true,
  state: ()=>({
    number: 100
  }),
  mutations: {
      changeNum(state, newNum) {
          state.num = newNum
      }
  },
  actions: {
    // changeNum({ commit }, newNum) {
    //     commit('changeNum', newNum)
    // }
    // 以下设置成全局的action
    changeNum: {
        root: true,
        handler({ commit }, newNum) {
            commit('changeNum', newNum)
        }
    }
  },
  getters: {
      aa() {
          return 555
      }
  }
}
// 导出 a 
export default a
// 2. 在总的store模块内导入
import a from './modules/a'
// 3. 在总的store模块内写上模块
export default new Vuex.Store({
  ...
  modules: {
    a,
    b
  }
  ...
})
```
```html
   <!-- 4. 使用 -->
  <div>展示带命名空间的 state: {{ num }}</div>
  <button @click="changeNum1(500)">直接通过模块内的 mutation 修改</button>
  <button @click="changeNum(1000)">直接通过模块内的 action 触发 mutation 修改</button>
  <div>{{ aa }}</div>
```
```js
 computed: {
    ...mapState({
      // num: (state) => {
      //   return state.a.number
      // }
      num: (state) => state.a.num,
    }),
    // ...mapGetters({
    //   aa: "a/aa",
    // }),
    ...mapGetters("a", {
      aa: "aa",
    }),
  },
  methods: {
    // ...mapMutations(['a/changeNum])
    // 以上是错误示范，mutation也并不是全局
    // ...mapMutations({
    //   changeNum1: "a/changeNum",
    // }),
    ...mapMutations('a', {
      changeNum1: 'changeNum'
    }),

    // ...mapActions('a', {
    //   changeNum2: 'changeNum'
    // }),
    // 全局的action不需要，加模块a
    ...mapActions(['changeNum'])
  }
```
###　async await
await 关键词作用是将后面的异步可以看做同步，就是等待异步执行之后在赋值，而且后续操作都会在之后执行,await 后面需要跟着 promise
```js
// getPosts 同下面的 getComments 的作用是一样的
async getPosts ({ commit }) {
  console.log(222)
  const res = await axios.get('http://localhost:3008/post')
  console.log(333)
  commit('getPosts', res.data) 
},
getComments ({ commit }) {
  axios.get('http://localhost:3008/comments').then(res => {
    commit('getComments', res.data)
  })
}
```
```js
async created(){
  // getPosts提前已经在js里拿到了，这里直接用即可
  // dispatch 执行完毕之后会返回一个promise
  await this.getPosts()
  console.log(111)
  // 输出顺序是  222  111  333  ，为什么自己去理解！
}
```

## vue
vue 的进阶阶段

### mixin混入

局部混入
```js
// 1. 先新建一个想要混入的js然后导出
const helloMixin = {
  // 该对象内的格式和组件的导出对象格式一样
  // 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”
  // 恰当的方式
  // 1. data  以组件本身为主
  // 2. 生命周期函数 自动合并(先执行自己的，再执行混入的)
  // 3. methods、components 和 directives 以组件本身为主
  data () {
    return {
      num: 100
    }
  },
  created () {
    console.log('mixin 内的 created hello');
}
// 2. 导出
export default helloMixin
```

```js
// 3. 在你想要用的组件下导入 ,并设置 mixins 属性就可以使用了
import helloMixin from "../mixins/hello";

export default {
  name: "MixinDemo",
  mixins: [helloMixin],
};
```

全局混入
```js
// main.js内，或者在其实js里使用
// 全局注册一个 mixin ，所有的组件自动合并该 minxin  慎用
Vue.mixin({
  created: function () {
    console.log('全局混入');
  }
})
```
### 自定义指令

#### v-html

  ```html
  <div v-html="htmlStr"></div> 
  ```
  ```js
    data() {
      return {
        htmlStr: '<span>123</span>'
      }
    },
  ```
#### directive 自定义指令

  ```html
    <input v-focus:haha.a='666' type="text">
    <br>
    <button v-my-click.once='handleClick'  >测试自定义的点击事件指令</button>

    <script>
      export default {
        methods: {
          handleClick() {
            console.log('事件触发了');
          }
        },
      };
    </script>
  ```
  
  ```js
    // 在main.js下导入 
    import './directives/index.js'

    // 注册一个全局自定义指令 `v-focus`，在js文件下写
    Vue.directive('focus', {
      // directive 方法的第二个参数会接受一个对象，对象内有一些钩子函数，用来设置指令的功能，钩子函数会在特定的情况下自动触发
      // 常用的两个钩子函数 
      // 1. bind 指令绑定到元素上自动触发，而且只触发一次，此钩子函数执行的时候，原生 dom 节点还没有显示在页面中
      // 2. inserted 当被绑定的元素插入到 DOM 中时

      inserted: function (el, binding) {
        // 下面这个name是我写的，前面可以写值也可以不写值
        // if (binding.name) {
        //     el.focus()
        // }
        if (binding.value) {
          el.focus()
        }
      },
      unbind(){
        // 当此组件销毁的时候执行此钩子
      }
    }),

    Vue.directive('my-click', {
      inserted: function (el, binding) {
        // if (binding.value) {
        //     let count = 0
        //     el.onclick = function () {
        //         count++
        //         if (binding.modifiers.once) {
        //             if (count === 1) {
        //                 binding.value()
        //             }
        //         } else {
        //             binding.value()
        //         }
        //     }
        // }
      const fun = function () {
          binding.value()
          if (binding.modifiers.once) {
              el.removeEventListener('click', fun)
          }
      }
      // remove 删的必须是 add 添加的
      if (binding.value) el.addEventListener('click', fun)
    }
  })

  ```

  ```js
    // 注册一个局部的自定义指令，在组件内部写
    directives: {
      focus: {
        // 指令的定义
        inserted: function (el) {
          el.focus()
        }
      }
    }
  ```

#### filter 过滤器
当全局过滤器和局部过滤器重名时，会采用局部过滤器。

```html
<!-- 过滤器的使用  需要写在模版语法中   {{ 参数 | 过滤器名称() }} -->
<span>时间: {{ showTime | formatTime(10,20)}}</span>

<script>
  data(){
    return {
      time: '2019-11-03T00:15:02.362Z'
    }
  },
  computed: {
    showTime() {
      // 当前的计算属性可以实现该组件内的时间格式化，但是其他组件想要使用的话还得再设置
      // 要实现全局功能可能想，将该方法写到一个 公共 js 内哪里使用哪里引入
      // 还可以将该功能写成 vue 的全局过滤器
      return moment(this.time).format('MM-DD HH:mm')
    }
  },

  // 局部过滤器(组件内)
  filters: {
    formatTime: function (value,a,b) {
      // value 指得是time
      if (!value) return ''
      return moment(value).format('MM-DD HH:mm')
    }
  }
 
</script>
```
```js
// 和 directive一样，先在main.js里导入 
import './filters/index.js'
//全局过滤器(新建的js里)
import Vue from 'vue'
import moment from 'moment'
Vue.filter('formatTime', function (value, a, b) {
  console.log(a);
  console.log(b);
  if (!value) return ''
  return moment(value).format('MM-DD HH:mm')
}
```


### vue 插件

插件通常用来为 Vue 添加全局功能。

```js
// 组件内，输出下面定义的axios，测试
created(){
  console.log($http)
  console.log($xx)
}
```
```js
import UseDemo from './components/UseDemo.vue'

// vue 的插件功能 , 其实就是给组件添加全局功能
// 1. 使用 Vue.prototype 向 vue 的实例内添加属性或方法
Vue.prototype.$http = 'axios'
// 2. 通过 Vue.use 方法   Vue.use(MyPlugin)
// 这种方法比较好，它会自动做检测功能（我也不太懂！） 
const MyPlugin = {
  install: function (Vue, a, b, c) {
    Vue.prototype.$xx = '测试'
    // 将 UseDemo 组件注册成全局组件，标签名是 UseDemo,直接使用即可，不需要引用和注册，前提是得把这个组件引用到现在的js里，在上面第一句
    // 前面是标签名，后面是组件名
    Vue.component('UseDemo', UseDemo)
    console.log(a, b, c);

  }
}
// 可以传参 1 2 3
Vue.use(MyPlugin, 1, 2, 3)
// Vue.use(MyPlugin) 会自动执行 MyPlugin 内的 install 方法,use 方法会自动检测全局的你的插件是否注册没注册

```

### 渲染函数 & JSX

创建函数式组件 两种方法 ：

1. Vue.component 方法创建函数组件，这种创建出来的组件是全局组件

    ```html
    <!--  第一种引用注册再使用，第二种直接使用即可-->
    <Vuetitle :level="1">hello 函数组件</Vuetitle>
    ```

    ```js
    // 第一种方法 全局组件 （js格式的）
    const Title = Vue.component('Vuetitle', {
      // render必须返回一个vnode节点（用createElement创建的），或者html节点，但是在全局组件中只能返回 vnode (可以是一个组件，也可以是 h 创建的) 不能返回 html 标签，这里不支持 jsx 语法， 局部组件里都可以创建
        render: function (createElement) {
            // createElement 就是创建虚拟dom节点(vnode),或取名 h
            return createElement(
                // 标签名称
                `h${this.level}`,
                // 标签里的文字，传过来的是文本节点，底层是一个对象
                this.$slots.default
            )
        },
        props: {
            level: {
                type: Number,
                default: 1
            }
        }
    })
    // 导出Title,
    export default Title
    ```

    ```js
    // 还可以在main.js里直接导入
    import "./components/title"
    // 但组件得写成以下形式，app里直接使用即可
    Vue.component('Vuetitle', {
      render: function (createElement) {
          return createElement(
              // 标签名称
              `h${this.level}`,
              // 标签里的文字
              this.$slots.default
          )
      },
      props: {
          level: {
              type: Number,
              default: 1
          }
      }
    })
    ```

上面标签里的文字因为没起名，所以默认名字是default，想要命名的话用以下方法，名字为text ：
  ```html
  <Vuetitle :level="1">
  <!-- 或者写成 #text -->
    <template v-slot:text>
      <a href="#">hello 函数组件</a>
    </template>
  </Vuetitle>
  ```
  ```js
  // 如下使用方法
  this.$slots.text
```

如果想在传过来的内容里添加标签可以如下设置：
  ```js
  // 这时h4里面有两个标签  a  span
  // 第一个参数是标签名，第二个是对象，里面设置一些属性，第三个是默认的文字
    return createElement(
        'h4',
        [
            createElement('a', {
                attrs: {
                    href: '#'
                }
            }, this.$slots.default),
            createElement('span', {
                style: {
                    cursor: 'pointer',
                    color: 'red'
                }
            }, this.$slots.default)
        ]
    )
  ```
想要添加一些事件,比如给span添加，可以如下设置：
  ```js
  render: function (createElement) {
    return createElement(
        'h5,
        [
          createElement('span', {
              on: {
                  click: this.test
              }
          }, this.$slots.default)
        ]
    )
  },
  methods: {
    test() {
        console.log('测试');
    }
  }, 
  // 或者把事件写上面
  on: {
    click(){
      console.log('测试')
    }
  }
  ```

2. 直接在 js 文件内写一个对象，对象内包含一个 render 方法即可，render 方法必须返回 html 节点（局部组件，哪用哪引）

    ```js
    // 下面的 js 内嵌套了 html 语法，我们称这种写法为 JSX 语法，默认这种语法是不支持的，需要 createElement(h) 支持,现在h可以省略了
    
    export default {
      render(h){
        // return h(`h${this.level}`, {}, '文字内容')
        // 上面是换标签名的，下面换标签名的方法需要定义一个变量
        const tag='h'+this.level
        // return <tag>局部函数组件</tag>
        // 如果想要使用传过来的文字，以下方法：(tag标签里是可以套其它标签的)
        return <tag>{this.$slots.default}</tag>
        
      },
      props: {
        level: {
          type: Number,
          default: 1
        }
      }
    }

    // 在想要用的父组件中引用 注册 使用
    import Title1 from "./components/titleComponent1";
    ```

绑定事件的写法

  ```js
  // return h(`h${this.level}`, { on: { click: this.handleClick } }, '文字内容')
  // JSX 语法内想要添加 js 需要先使用 {} 包裹，  onclick也能用
  return <h3 on-click={this.handleClick}>局部函数组件</h3>
  ```
  
### 小例子

在父组件里的方法里自己定义一个render函数，决定要生成什么标签，然后传给最终的js组件，用props，type是Function接收（借助render函数传递自定义的html内容）

```html
<List :arr="['香蕉', '西瓜', '平果']" :render="render" />
```
```js
// 见vue-advance里的 List组件(苹果香蕉大鸭梨)
// 父组件内定义的render方法
methods: {
  render(h, item) {
    // 下面是 jsx 语法， 默认不支持 因为不是函数组件内部的 render 函数,所以需要函数组件内传递过来 h
    return <h1>{item}</h1>
  }
}

// 函数组件内 (js)
  render(h) {
    // 这里判断的是用户自己写没写，没写默认就是span标签
      return <li>
          {this.render ? this.render(h, this.item) : <span>{this.item}</span>}
      </li>
  },
  props: {
      item: {
          type: String,
          required: true
      },
      render: {
          type: Function,
      },
  }
}
```

还有一种方法是借助作用域插槽实现列表内容自定义（这种更简单）

```html
<!-- 父组件  -->
<List2 :data="['香蕉1', '西瓜1', '平果1']">
  <template v-slot:a="{ item }">
    <h2>{{ item }}</h2>
  </template>
</List2>

<!-- 子组件 -->
<ul>
  <li v-for="item in data" :key="item"><slot name="a" :item="item" /></li>
</ul>

```


### 变成插件的方法
```js
// 1. use方法必须传递个对象，对象下必须有个install方法(插件一般是在install方法下的)
const Title = {
    install: function (Vue) {
        Vue.component('Vuetitle', {
            render: function (createElement) {
                return createElement(
                    `h${this.level}`,
                    // this.$slots.text
                    this.$slots.default
                )
            },
            props: {
                level: {
                    type: Number,
                    default: 1
                }
            }
        })
    }
}
// 2.
export default Title
// 3. 在plugins/Title里
import Vue from "vue"
// Vuetitle 这个名字必须和自己新建的组件名一样
import Vuetitle from "../components/title"
Vue.use(Vuetitle) 

// 3. 在main.js里引入
import "./plugins/Title"

// 或者 没有plugins/Title，就把这里面的内容写进main.js 引用
```

### 用 node + express 搭建简易后台服务器

1. express : node的包，快速搭建服务器，安装express依赖
2. 在外面（src外）新建一个server.js文件，里面引用：

```js
  // es6语法针对src里的东西，怕用不了
  // import express from "express"
  // 下面是node语法：
  const express =require('express')
  cosnt app = express()
  // /menus是一个接口，需要拼上下面的地址,把对象下的a转换成json再返出去(get方法返回一个json数据)
  app.get('/menus',function(req,res){
    res.json({
      a:[1,2,3]
    })
  })
  app.listen(3000,function(){
    console.log('服务器已经启动，http://localhost:3000/')
  })
  // 以上就起了一个node服务
```
3. 运行服务器：node server.js
4. 在组件里发axios请求来拿数据
```js
const res = await axios.get('http://localhost:3000/menus')
console.log(res.data.menuList)
```
5. 小知识：此时会遇到跨域问题，两个不同的服务器进行互动就是跨域，http://localhost:8080,协议 域名 端口，其中一个不一样就叫跨域，比如和 http://localhost:3000 就不一样，怎么解决此问题呢？
```js
// 写在app.get上方
app.all('*', (req, res, next) => {
  // 响应头的设置，我的后台支持跨域请求
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "Content-Type");
  res.header("Access-Control-Allow-Methods", "*");
  res.header("Content-Type", "application/json;charset=utf-8");
  next();
})
```
6. 小知识：对反映出来的数据进行一些处理
```js
axios.defaults.baseURL = "http://localhost:3000";
// 响应拦截器
axios.interceptors.response.use((response) => {
  // axios 就会以这个函数的返回值作为响应的结果
  return response.data;
});

// 上面写了默认基地址，这里就可以直接写后面的地址
const res = await axios.get("/menus");
console.log(res.menuList)
```
7. 小知识：解析post传过来的数据
```js
// 传参
await axios.post("/menus", { text });
// 先下载，命令行中：npm i body-parser
// 后台中服务器接收
const bodyParser = require('body-parser');
app.use(bodyParser.json())

app.post('/menus', function (req, res) {
  // 使用 text前要加上 req.body
  console.log(req.body.text)
}

```

### 浏览器的本地存储
```html
    <button class="set">存储</button>
    <button class="get">获取</button>
    <button class="del">删除</button>
    <h2>浏览器的本地存储</h2>
    <script>
        // sessionStorage：关闭了网页之后存储的就没有了
        // localStoreage：关闭了网页之后存储的依然在，除非用以下手法手动删除
        document.querySelector('.set').onclick = function () {
            sessionStorage.setItem('password', JSON.stringify({ x: 123456 }))
            // x 自动存的是string，结果是  获取不到对象 结果是 [object Object]，所以要想取到对象，需要用JSON.stringify()
            sessionStorage.setItem('username', '小张')
        }
        document.querySelector('.get').onclick = function () {
            const pas = sessionStorage.getItem("password")
            // 因为拿到的结果是json字符串，所以需要json.parse做解析才能拿到对象
            console.log(JSON.parse(pas).x);
        }
        document.querySelector('.del').onclick = function () {
            // sessionStorage.removeItem("username")
            sessionStorage.clear()
        }

    </script>
```

### 小例子，自己做一个路由插件
具体思路参考 mini-vue-router 小例子，自己创建 router.js
包含的小知识：
```js
// new Vue 创建一个vue实例(类)，其实就是一个vue组件，这个组件是根组件，是属于vue内所有组件的祖先，也就是其他组件(App..)都会继承该组件 ，new Vue 传递的参数可以使用组件的this.$options获取
// 这里引入了router 那么所有的组件内都多了：
// $router 和 $route,   $router 内指得就是VueRouter类，$route内指得是当前路由里的一些信息(没用)
new Vue({
  router,
  render:h=>h(App)
}).$mount('#app')

// 指得是：VueRouter是一个插件，需要使用install方法
Vue.use(VueRouter)

// 指得是：new VueRouter 意思是VueRouter是一个类(也算是一个实例)，这里传参过去，对面需要用constructor 接收这个参数，
const router = new VueRouter({
  mode: 'hash',
  base: process.env.BASE_URL,
  routes
})

// install 方法第一个参数可以接收一个Vue，此 Vue 指得是整个大的Vue组件,这样就可以使用Vue来添加一些公共的东西了
let Vue
VueRouter.install = _Vue =>{
 Vue = _Vue
// 制作插件的功能就是给 vue 组件做一个全局的功能，所以放在这里比较合适
// Vue.prototype.$router = VueRouter
}
```
### 解决跨域方法
- 做代理(将我们本地的localhost：8080让别人云做代理，帮我们请求)
  1. 先新建一个vue.config.js的文件，和package.json同级
  ```js
 
  // node 的一个导出方式 
  module.exports = {
    // 开发的一个服务器下做个代理
    devServer: {
        // 修改了配置得重启服务
        proxy: {
          '/api': {
              target: 'https://vue-js.com/api/v1',
              ws: true,
              // 需要虚拟的主机地址
              changeOrigin: true,
              // 带着api的请求要发到target里，然后必须重写api
              pathRewrite: {
                  "^/api": ""
              }
            }
        }
    }
  }

  // 需要跨域访问的是 https://vue-js.com/api/v1/topics
  // axios.get('api/topics')，遇到api就变target的地址
  // 这样就可以访问想要跨域访问的那个地址了
  // 此代理只对本地服务器生效，如果用node随便打开了一个服务器，此代理是不管用的
  // 代理是vuecli做的,vuecli是搭建vue的环境的一个工具
  ```

## typescript

1. 先建立一个.ts结尾的文件(index.js)
2. 再安装 typescript: npm install -g typescript
3. 然后在命令行中输入命令: tsc index.ts , 自动就多出一个index.js(js文件内把ts解析成js)
4. 然后在html中导入 js 文件，就可以使用了！
(想要查看ts文件可以用node：ts-node index.ts  这条命令 = node index.js)
(想要在页面中执行只要修改了就要重新执行命令：tsc index.ts)

```ts
// 布尔
let isDemo: boolean = true
// 以下是出错的
// let isDone1: boolean = new boolean(false)
let isDone1:Boolean = new Boolean(false)

// 数字
// 变量不想赋值成任何的初始值，可以赋值 undefined
let num: number = undefined

// 字符串
let str:string='hello'

// undefined 
// undefined 是所有类型的子类型
let und: undefined = undefined

// null
let nul: null = null

// void 空值
// 只能是null和undefined，定义一个空值没有用，一般在函数的返回值的时候设置
let unusable: void = undefined

// any 任意值
// 可以赋值任意类型的值,没定义默认为any
let anything: any = 'hello'
let something
something = 7
something = 'hello'

// 类型推论 声明变量的时候没有声明类型 如果赋值了 类型推论就会帮助你自动定义类型
let num3 = 10
num3 = 'hello world'
// 此时就会出错，因为num3以为被认为是number了

// 联合类型
// 既可以是数字类型也可以是字符串类型
let number: number | string = 10

// 数字数组
let arr1: (number | string)[] = [3, 4, 5, '6', 7]
// 下面默认是number[]
let arr2 = [1, 2, 3]
// 数组的泛型表示法  Array<元素类型>
let arr: Array<number> = [1, 2, 3]

// 元组 元组类型允许表示一个已知元素数量和类型的数组
let x: [number, string] = [1, '2']
// x[2]=8 会出错，元组已经定义好长度了，不能单加

// 对象类型 Object
// 需要定义一个接口
interface Person {
    name: string,
    // 可选属性 加 '?'
    age?: number,
    hobby: string[],
    // 规定下面所有的属性，若把any换成number或者其它，写了会对之前存在的属性进行校验，会出错！
    [propName: string]: any,
    // 只读属性不能修改
    readonly firstName: string
}
let user: Person = {
    // 默认不能缺少任意一个属性，对应到Person接口(可加 ?)
    name: '花花',
    age: 28,
    hobby: ['1', '2'],
    x: 10,
    y: 'hello',
    firstName: '张'
}

// 函数类型
// 在ts内函数的声明，需要声明参数和返回值的类型
// 函数式的创建
function add(a: number, b: number): number {
    // 如果类型不写，就默认为any
    return a + b
}

// 表达式创建
// 必须设置成变量的类型: 函数类型 (参数类型)=>返回值类型 = 函数
// 类型推论可以省略变量(add1)的函数类型声明
const add1: (a: number, b: number) => number = function (a: number, b: number) {
    return a + b
    // 函数没有返回值，默认返回undefined
}
// 箭头函数
// const add1: (a: number, b: number) => number = (a: number, b: number): number => a + b

// 函数没有返回值，返回值类型设置成 void
function fun(x: string): void {
    console.log(x);
    // void 必须返回 null 或者 undefined 或者不写 return
}

function fun1(x = 'hello', y?: string, ...rest: number[]): void {
  // 如果没传 y 就是 undefined
    console.log(x + y);
    console.log(rest);
    // rest 拿到的就是1-5的数组(剩余参数)
}
// 'world' 必须得传，要不然就没有剩余参数了
fun1('hello', 'world', 1, 2, 3, 4, 5)


// 例子： 创建一个函数，将传递的数字或者字符串进行倒序输出
// 函数重载，解决定义不明确问题：传什么类型，拿什么类型
function reverse(x: number): number
function reverse(x: string): string
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''))
    } else {
        return x.split('').reverse().join('')
    }
}
console.log(reverse('hello'));

// 类型断言:将联合类型断言为其中某一种类型
// 将任意一个类型断言为any类型
(function y() {
    // window.z=10  出错
    (window as any).z = 10
    // window全局对象在ts中默认不能使用，需要定义,只有文件运行在浏览器上才会有window
})()
// 1. 值 as 类型 (常用)
 if (typeof (animal as Fish).swim === 'function')
// 2. <类型>值 
if (typeof (<Fish>animal).swim === 'function')

interface Cat {
    name: string
    // 定义一个run方法，是空值，不是返回空值
    run(): void
}
interface Fish {
    name: string
    swim(): void
}
const cat: Cat = {
    name: '小轩',
    run: function () {
        console.log('跑');
    }
}
function isFish(animal: Cat | Fish): boolean {
    // if (animal.swim) {
    // 在这直接判断animal是否拥有swim属性会报错:ts 编译失败
    // 因为Cat没有此属性 
    // 需要使用类型断言，先断言animal是Fish接口类型
    // 判断是不是函数更为严谨
    // if (typeof (animal as Fish).swim === 'function') {
    if (typeof (<Fish>animal).swim === 'function') {
        return true
    }
    return false
}
console.log(isFish(cat)); // false


// 内置对象
const date = new Date()
const re = new RegExp('[abc]')

// DOM  document
console.log(document);
// 单一元素的类型 HTMLElement
const box: HTMLElement = document.querySelector('.box')
// 元素集合类型 NodeList
const box1: NodeList = document.querySelectorAll('.box')
// MouseEvent鼠标事件对象的类型
box.onclick = function (e: MouseEvent): void {
    console.log(e);
}
box.addEventListener('click', function (e) {
    console.log(e.target);

}),

// BOM  window (上面需要加逗号)
// window.z = 88  出错，必须类型断言
(window as any).z = 88
console.log((any<window>).z);

// 类型别名
// 使用 type 创建任意的类型别名
type Num1 = number | string
const num1: Num1 = 10
type numArr = number[]
const numArr1: numArr = [1, 2, 3]

// 自面量类型
// 只能赋值其中之一
type Fruit = 'apple' | 'orange' | 'pear'
const fruit: Fruit = 'apple'

// 玫举类型
// 一般存储的是常量，第一个如果赋值为数字，那后面的数依次类推，默认就为0
// 如果第前面的赋值为其它，那后面的必须也赋值，否则出错
// log玫举类型，是 {'0':'Sun', Sun:0}
enum Days { Sun = 0, Mon, Tue, Web, Thu, Fri, Sat }
// const day: Days = Days['Tue']
// console.log(day);   2
// console.log(Days[2]);  Tue
const day: string = 'Mon'
if (Days[day] === 1) {
    console.log('周一');
}

// 类
class Person1 {
    // 类内的属性和方法需要先定义好类型
    // 然后constructor内才能给这些属性或者方法赋值
    // public name:string 简写如下：
    // name: string
    age: number
    // 也可以在里面声明
    constructor(public name: string, age: number) {
        this.name = name
        this.age = age
    }
    say() {
        console.log(this.name);
    }
}
// 1. const user1: Person1 = new Person1('小张', 2)
// 可以写成以下：2.
const user1: Person1 = {
    name: '小红',
    age: 2,
    say() {
        console.log('888');
    }
    // 必须写say()，否则会报错
}
user1.say()
// 这里执行的是888，覆盖住了1里的say，所以2不如1好

// 继承
class Animal {
    name: string
    constructor(name: string) {
        this.name = name
    }
    sayHi() {
        console.log(`my name is ${this.name}`);
    }
}
class Fish extends Animal {
    constructor(name: string) {
        super(name)
    }
}
const fish = new Fish('小小')
console.log(fish.name);  // 小小
fish.sayHi() // my name is 小小
// 小知识：log(fish) : Fish {name: "小小"}   
// Fish 的_proto_是 Animal，animal下有constructor，还有_proto_是sayHi

// ts 里面可以对类使用几个修饰符(属性，方法)
// public 默认，能改能用
// private 只能在类中访问，别处只能看不能用
// readonly 只读，能访问不能修改
// protected 子类可以访问

// 类里面的存取器，属性和获取和修改
class People {
    constructor(name: string) {
        this.name = name
    }
    get name() {
        return ''
    }
    set name(value) {
        console.log(value);
    }
}
const beauty:People = new People ('小张')
beauty.name='小峰'
// 小张    小峰
// name 一修改就触发 set

// 泛型 
// 创建一个任意长度的数组，而且创建出来的数组每一项是有默认值的
function createArray<T>(length: number, value: T): Array<T> {
    let res: T[] = []
    for (let i = 0; i < length; i++) {
        res.push(value)
    }
    return res
}
const res = createArray<string>(4, 'x')
// 按照之前的写法，res就没有确定的类型，现在的做法是为了让res的类型固定些
// const res = createArray(4, 'x')
// 类型推论可以省略函数传递的泛型，也就是把下面的string省略掉

// 声明文件
// 我们要使用第三方插件 jquery
// 需要安装 jquery 和 @types/jquery (用来声明jquery的)，导入方式换成下面这种，
import $ = require('jquery')
console.log($);  // Function
```

## 在 vue2.x 中使用 ts

格式化函数时，函数名称或function关键字与开始参数之间会自动没有空格。想要让它有空格，需要在 .gitignore 里 加上一句话：`space-before-function-paren = 0`

安装 Vue TypeScript Snippets 0.1.3 插件，就可以使用 v-ts-c 

导入子组件、methods、data：
```ts
import ButtonDemo from '../components/ButtonDemo.vue'
// 必须加后缀名 .vue
import { Component, Vue } from 'vue-property-decorator'
// 我们通过 vue-property-decorator 导入了 Vue 以及 Component
//  vue-property-decorator 是一个vue类组件装饰器 快速方便的使用类组件内的属性和方法

// @Component 装饰器方法:不可省
// 作用1：可以导入子组件
// 作用2：声明生命周期
// 作用3：设置计算属性
@Component({
  components: {
    ButtonDemo
  }
})
export default class Home extends Vue {
  // data 和 methods 直接写在类里
  count = 0
  add() {
    this.count++
  }
  sub() {
    this.count--
  }
}

```

子组件内：Prop、Emit
```ts
// 父组件：
<ButtonDemo @add1="add" text="默认按钮"></ButtonDemo>

// 1. 子组件：对应不换名的
<button @click="add1">{{ text }}</button>

// 2. 子组件：对应换名的
<button @click="plus">{{ text }}</button>

export default class ButtonDemo extends Vue {
  // Prop 装饰器可以获取父组件传递的props
  // 需要在vue-property-decorator里导入Prop
  // Prop()里的String可写可不写，尽量写,写上就是校验
  // 1. 不带校验的写法，可以写在一行
  // @Prop(String)
  // text: string
  // 2. 带校验的写法
  @Prop({
    type: String,
    default: '按钮'
  })
  // prop 有时会提示错误:你的prop没有赋值(空值)
  // 1. 直接在 text 后面加一个 !    2. 给text 声明一个联合类型  string | undefined
  text!: string

  // 自定义事件，接收事件
  // 两个事件(自动合并)，先执行子组件的再执行父组件的
  // 1. 不换名的自定义事件方法
  @Emit()
  add1(){
    console.log('子组件的 add1')
  }
  // 2. 换名的自定义事件方法
  @Emit('add1')
  plus() {}
}
```

生命周期、计算属性、侦听器：
```html
<div>
  <router-link to="/?tab=all">去全部</router-link> |
  <router-link to="/?tab=ask">去问答</router-link>
</div>
```
```ts
// 1. 生命周期写在Component里
@Component({
  mounted() {
    console.log('子组件的mounted')
  },
  // 1. 计算属性写在Component里的computed里
  computed: {
    num() {
      return 666
    }
  }
})

export default class ButtonDemo extends Vue {
  // 2. 生命周期写在类里
  created() {
    console.log('子组件的created')
  }

  @Watch('$route.query.tab',{ immediate: true })
  onTabChange(newValue: string, oldValue: string) {
    console.log(newValue, oldValue)
  }

  // 2. 计算属性写在类里，用 get(可以定义返回值类型)
  get fullName(): String {
    return 'name'
  }
  set fullName(newValue: String) {
    console.log('fullname 修改了')
  }
}
```

路由( $route, $router )的小知识：
```ts
import { Route } from "vue-router"
export default class Home extends Vue {
  // 一般情况需要定义类型，可以给上面导入的 Route 类型
  // 可以省略类型(老师建议)
  $route: Route
  test() {
    // 这里 $route 没有定义 可以使用，但提示错误 
    // 需要在上面定义一下
    console.log(this.$route.query)
  }
}
```

state: 拿store里的state
```ts
export default class Count extends Vue {
// 1. 需要先安装运行依赖：vuex-class
// 2. 导入：import { State } from 'vuex-class'
// 3. store 中取 str，给str1
// 注意：这种只适用于state里，模块里的不能用
  @State('str') 
  str1!: string
}
```

PropSync
```ts
// 父组件内：
<Count :count.sync="count" />

// 子组件内：显示父组件的count
<div> {{ cnt }} </div>
<button @click="changeCount(2200)">修改父组件传递的cnt</button>

export default class Count extends Vue {
  @PropSync('count', { type: Number })
  // cnt 和 count 不能重名
  cnt!: number

  // 1. 修改 cnt (以前的方法)
  changeCount() {
    this.$emit('update:count', 200)
  }
  // 2. 修改 cnt (现在的方法)
  @Emit('update:count')
  changeCount(num: number) {}
}
```

Model
```ts
// 父组件内：
<Count v-model="text" />

// 子组件内：
// 1. 第一种修改方法
<input type="text" :value='value1' @change="$emit('changeText',$event.target.value)">

// 2. 第二种修改方法
<input type="text" :value="value1" @input="changeText($event.target.value)" />

export default class Count extends Vue {
  // 第一个参数是传递的事件，默认input，(给了一个自变量input1,上面使用的是input1)，第二个是传递的变量的类型(这里是text也就是value的类型)
  // 装饰器装饰的就是传递过来的 props 也就是 value1，value1是给传过来的value换了个名字，用value也行
  // 1. 第一种方法 
  @Model('changeText', { type: String })
  value1!: string
  
  // 2.第二种方法:个人认为第二种方法多余！
  @Model('input', { type: String })
  value1!: string
  @Emit('input')
  changeText(str: string) {}
}
```

(state) store: vue 内 ts 写法 
```ts
// 1. 需要安装运行依赖 vuex-module-decorators，借助它去创建 store 的模块
// 2. 导入： VuexModule: 是用来创建模块的类，这个类需要 Module 装饰器 
import { VuexModule, Module } from "vuex-module-decorators"
// 3. 创建一个类继承 VuexModule
export default class Company extends VuexModule {
    // state 
    companyName = '第嘉'
}
// 4. 在路由的index里导入，写进模块中，就能使用了
import company from "./modules/company"
export default new Vuex.Store({
    modules: {
      company
    }
})
// 5. 使用
this.$store.state.company.companyName
```

@Module 装饰器内直接将这个模块添加到 store 内，不需要在创建 store 的时候导入模块，再添加到 modules 内 的方法。

模块(company.ts)内:
```ts
interface companyInfo {
  name: string,
    created_at: string,
    info: string
}
// 如果有接口，可以把总接口也导出，给到下面company的类型
export interface ICompany {
    companyInfo:companyInfo
    arr:Array<number>
}

// 1. 在模块的文件下先导入 store 下的 index:  `import store from "../index"`
// 2. 在装饰器内 写上store 并且添加 dynamic 属性 属性值为 true
@Module({
    name: 'company',
    store,
    // 动态创建模块 将模块自动添加到 store 内
    dynamic: true
})
class Company extends VuexModule {
    companyInfo: companyInfo = {
        name: '第嘉',
        created_at: '2020-12-11',
        info: '前端学习营地'
    }
    arr: Array<number> = [1,2,3]
}
// 4. 导出模块给组件使用
export const CompanyStore = getModule(Company)
```
store 的 index.ts 内：
```ts
// 如果company.ts 下有导出的接口，可以先导入接口
import { ICompany } from "./modules/company"
// 再把下面company的类型换成： company: ICompany

// 1. 写个接口 IRootState,接口名任意
interface IRootState {
  company: any
}
// 2. 把 IRootState 写进 Store 内
export default new Vuex.Store<IRootState>({})
```
company.vue内：
```ts
// 先导入模块内导出的CompanyStore
import { CompanyStore } from '../store/modules/company'
// 使用 CompanyStore 内是所有的state
console.log(CompanyStore)
console.log(this.$store.state.company) 
// 有 companyInfo 对象和 companyName 字符
```

Mutation,get,Action
```ts
// 假装给action做的异步请求
const getList = () => new Promise<Array<number>>(resolve => {
    setTimeout(() => {
        resolve([1, 2, 3, 4, 5, 6, 7])
    }, 1000);
})

class Company extends VuexModule {
    arr: Array<number> = []

    // Mutation Action 在上面先导入
    @Mutation
    getArr(payload: Array<number>) {
        this.arr = payload
    }

    get len() {
        return this.arr.length
    }

    @Action
    async fetchArr() {
        const newArr = await getList()
        this.getArr(newArr)
    }
}
// 在组件内使用：
export default class Company extends Vue {
  get arr() {
    return CompanyStore.arr
  }
  created(){
    // CompanyStore.getArr([1,2,3])
    CompanyStore.fetchArr([1,2,3])
  }
}
```